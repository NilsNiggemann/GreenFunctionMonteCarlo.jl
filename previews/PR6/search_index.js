var documenterSearchIndex = {"docs":
[{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractConfig","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractConfig","text":"AbstractConfig{T,N}\n\nAn abstract type that represents a configuration (i.e. spins, bosons on a lattice).  This type is a subtype of AbstractArray{T,N}.\n\nParameters\n\nT: The type of the elements in the configuration.\nN: The number of dimensions of the configuration.\n\nInterface\n\nBase.parent(x::AbstractConfig): return the parent array\nBase.copy(x::AbstractConfig): create a full copy of the configuration\napply!(x::AbstractConfig, move::Any): apply a move to the configuration\nfulfills_constraints(x::AbstractConfig, HilbertSpace::AbstractHilbertSpace): check if the configuration satisfies the constraints of the Hilbert space\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractConstraint","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractConstraint","text":"AbstractConstraint\n\nAn abstract type representing a constraint in the context of a Hilbert space.\n\nInterface\n\n(c)(x::AbstractArray): Check if the configuration x satisfies the constraint.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractDiagObservable","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractDiagObservable","text":"Abstract supertype for observables which are diagonal in the computational basis and may be measured for free in GFMC. An observable must be a function that takes a configuration and returns an array.\n\nInterface:\n\nobs(::O) returns the buffer array for the output of the observable.\nO(out,Conf): Writes the observable for the given configuration to the preallocated array out. Returns out.\nBase.copy(O::O): Returns a copy of the observable.\n\nIf no preallocated array is given, the observable defaults to using the buffer array obs(O).\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGFMCProblem","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGFMCProblem","text":"Abstract type for GFMC problems.\n\nInterface:\n\nrunGFMC!(problem::AbstractGFMCProblem,args...;kwargs...): Run the GFMC algorithm for the given problem.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGuidingFunction","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGuidingFunction","text":"AbstractGuidingFunction\n\nAn abstract type for all guiding function implementations in Green Function Monte Carlo. Subtypes of this correspond to implementations of concrete guiding functions, particularly variational wavefunctions. For optimal performance, it is recommended to implement the function logpsidiff! for the specific guiding function type.\n\nInterface\n\nlogψ(x::AbstractArray): return the logarithm of the guiding function evaluated at the configuration x.\nlogψ(x::AbstractArray, H::AbstractHilbertSpace): return the logarithm of the guiding function evaluated at the configuration x in the specified HilbertSpace.\nlog_psi_diff(x::AbstractArray, dx::AbstractArray, logψ::AbstractGuidingFunction, Buffer::AbstractGuidingFunctionBuffer, Hilbert::AbstractHilbertSpace): return the logarithm of the ratio of the guiding function evaluated at the configuration x and x+dx in the specified HilbertSpace. Returns -Inf if the move is not applicable.\nget_params(logψ::AbstractGuidingFunction): return the parameters of the guiding function as a linear Array. It is recommended to use RecursiveArrayTools.jl for this purpose.\n\nInterface (optional)\n\nallocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer): allocate NBuffers instances of a buffer for the guiding function. Defaults to an array of EmptyGWFBuffer instances.\ncompute_GWF_buffer!(Buffer::AbstractGuidingFunctionBuffer, logψ::AbstractGuidingFunction, x): compute the full buffer for the guiding function at the configuration x. \npre_move_affect!(Buffer::AbstractGuidingFunctionBuffer, x, moves, logψ::AbstractGuidingFunction): perform any necessary operations before computing ratios ψx´_ψx.\npost_move_affect!(Buffer::AbstractGuidingFunctionBuffer, x, dx, logψ::AbstractGuidingFunction): perform any necessary operations after the move is applied.\nHDF5.h5write(file::AbstractString, name::AbstractString, logψ::AbstractGuidingFunction): write the guiding function to an HDF5 file.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","text":"AbstractGuidingFunctionBuffer\n\nAn abstract type that serves as a base for defining guiding function buffer structures. \n\nInterface\n\nsetBuffer!(BA::AbstractGuidingFunctionBuffer, BB::AbstractGuidingFunctionBuffer): set the buffer BA to the values of the buffer BB.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractHilbertSpace","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractHilbertSpace","text":"AbstractHilbertSpace\n\nAn abstract type representing a Hilbert space. This type serves as a base for defining various specific Hilbert spaces used in the project. Generally, a hilbert space should be defined by the number of sites, the number of local degrees of freedom (i.e. spin), and the constraint that the configurations must satisfy. \n\nInterface\n\nconstraint(HilbertSpace::AbstractHilbertSpace): Return the constraint that the configurations in the Hilbert space must satisfy.\nBase.size(HilbertSpace::AbstractHilbertSpace): Return the size of a config in the Hilbert space.\n\nInterface (optional)\n\nfulfills_constraint(x,HilbertSpace::AbstractHilbertSpace): Check if the given configuration x satisfies the constraint of the specified HilbertSpace. Defaults to constraint(HilbertSpace)(x).\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractMove","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractMove","text":"AbstractMove\n\nAbstract type representing a move, i.e. an operation that changes a configuration x to a new configuration x'.\n\nAbstract type representing a move operation in the context of Green Function Monte Carlo simulations.\n\nThis abstract type serves as a base for defining various move operations that can be performed during the simulation process. Specific move types should inherit from this abstract type and implement the required functionality.\n\nInterface\n\napply!(x::AbstractConfig, move::AbstractMove): Apply the move to the configuration x.\nisapplicable(x::AbstractConfig, move::AbstractMove, HilbertSpace::AbstractHilbertSpace): Check if the move is applicable to the configuration x within the specified HilbertSpace.\naffected_sites(move::AbstractMove): Return the sites affected by the move.\n\nIt is further necessary to implement either of the three methods:\n\nmove_dx(move::AbstractMove) Return the values of the move applied to the configuration x. i.e. x′ - x.\nmove_dx_before(move::AbstractMove,x::AbstractConfig: Uses x to compute the move values before applying the move to the configuration. Defaults to move_dx(move)\nmove_dx_after(move::AbstractMove,x::AbstractConfig): Uses x to compute the move values after applying the move to the configuration. Defaults to move_dx(move)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractObservable","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractObservable","text":"Abstract supertype for observables. An observable must be a function that takes a spin configuration and returns an array. To define a subtype of O of AbstractObservable, one must define the following functions:\n\nobs(::O) returns the buffer array for the output of the observable.\nO(out,Conf): Writes the observable for the given configuration to the preallocated array out. Returns out.\nBase.copy(O::O): Returns a copy of the observable.\n\nIf no preallocated array is given, the observable defaults to using the buffer array obs(O).\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractObserver","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractObserver","text":"Abstract supertype for observables in GFMC which are recorded during the run. Observables should always contain the table recording reconfiguration processes, the energies, and the total weights of each Markov step.\n\nInterface:\n\nsaveObservables_before!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers.\nsaveObservables_after!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers after reconfiguration.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractOperator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractOperator","text":"AbstractOperator\n\nAn abstract type representing a general operator. This serves as a base type for defining various specific operators in the context of the Green Function Monte Carlo project.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractPropagator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractPropagator","text":"AbstractPropagator\n\nAn abstract type representing a propagator. Examples include discrete or continuous time methods.\n\nInterface:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng()): Propagate the walkers in the ensemble using the specified moves and parameters.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractReconfigurationScheme","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractReconfigurationScheme","text":"AbstractReconfigurationScheme\n\nAn abstract type that serves as a base for defining different reconfiguration strategies  in the context of the Green Function Monte Carlo framework. \n\nInterface\n\nreconfigurateWalkers!(Walkers::AbstractWalkerEnsemble,reconfiguration::AbstractReconfigurationScheme,rng::Random.AbstractRNG)\nget_reconfigurationList(reconfiguration::AbstractReconfigurationScheme)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractSignFreeOperator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractSignFreeOperator","text":"AbstractSignFreeOperator <: AbstractOperator\n\nAn abstract type representing a sign-free operator in the context of Green Function Monte Carlo simulations. \n\nInterface:\n\nget_diagonal(O::AbstractSignFreeOperator): return the diagonal operator associated with the sign-free operator O\nget_offdiagonal_elements(O::AbstractSignFreeOperator): return the weights associated with the off-diagonal operator O\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractWalkerEnsemble","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractWalkerEnsemble","text":"AbstractWalkerEnsemble\n\nAn abstract type that represents an ensemble of configurations (i.e. spins, bosons on a lattice for each walker) in the context of the Green Function Monte Carlo project. \n\nInterface (required)\n\ngetConfig(X::AbstractWalkerEnsemble,α):  get the configuration of the α-th walker in the ensemble.\ngetMoveWeights(X::AbstractWalkerEnsemble,α): get the weights of the moves for the α-th walker in the ensemble.\ngetBuffer(X::AbstractWalkerEnsemble,α): get the buffer associated with the α-th walker in the ensemble.\ngetWalkerWeights(X::AbstractWalkerEnsemble): get the weights of the Walkers in the ensemble.\n\nInterface (optional)\n\nBase.eachindex(X::AbstractWalkerEnsemble): iterate over the indices of the ensemble.\ngetNWalkers(X::AbstractWalkerEnsemble): get the number of walkers in the ensemble.\ngetConfigs(X::AbstractWalkerEnsemble): get all configurations in the ensemble.\ngetLocalEnergies(X::AbstractWalkerEnsemble): get the local energies of the walkers in the ensemble.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.BasicAccumulator","page":"Reference","title":"GreenFunctionMonteCarlo.BasicAccumulator","text":"BasicAccumulator{T_high<:AbstractFloat} <: AbstractObserver\n\nA basic observer struct for accumulating measurements in Monte Carlo simulations.\n\nType Parameters\n\nT_high<:AbstractFloat: The floating-point type used for high-precision accumulation.\n\nDescription\n\nA structure that represents a basic accumulator for observing energy and weights during simulations. Instead of storing observables at each step, the expectation values are computed on the fly, reducing the storage requirements significantly. Note that it is advisable to use a good guess of the average weight in the propagator to reduce numerical precision loss.\n\nSee Also\n\nAbstractObserver\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.BasicObserver","page":"Reference","title":"GreenFunctionMonteCarlo.BasicObserver","text":"struct BasicObserver{DT<:AbstractFloat} <: AbstractObserver\n\nSaves the energies, weights and reconfigurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the energies and weights.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.BosonConfig","page":"Reference","title":"GreenFunctionMonteCarlo.BosonConfig","text":"struct BosonConfig{T, N, Arr<:AbstractArray{T, N}} <: AbstractConfig{T, N}\n\nRepresents a configuration of bosonic particles in a given formalism. This structure is parameterized by:\n\nT: The type of the elements in the configuration (e.g., Bool or UInt8).\nN: The dimensionality of the configuration space.\nArr<:AbstractArray{T, N}: The type of the array used to store the configuration data, which must be a subtype of AbstractArray with element type T and dimensionality N.\n\nThis type is a subtype of AbstractConfig{T, N}, which provides a common interface for configurations in the system and implements the AbstractArray interface.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.BosonHilbertSpace","page":"Reference","title":"GreenFunctionMonteCarlo.BosonHilbertSpace","text":"struct BosonHilbertSpace{Cons<:AbstractConstraint} <: AbstractHilbertSpace\n\nA structure representing the Hilbert space for bosonic systems.\n\nType Parameters\n\nCons<:AbstractConstraint: A type that defines the constraints applied to the bosonic Hilbert space. This allows for flexible customization of the space's properties.\n\nSupertype\n\nAbstractHilbertSpace: This structure is a subtype of AbstractHilbertSpace, indicating that it represents a specific type of quantum mechanical Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.CombinedObserver","page":"Reference","title":"GreenFunctionMonteCarlo.CombinedObserver","text":"CombinedObserver{T}\n\nA struct that represents a combined observer, which is a collection of multiple observers grouped together.  This allows for observing multiple quantities or behaviors simultaneously.\n\nFields\n\nObservers::T: A collection containing the individual observers.\n\nUsage\n\nThis struct is useful for combining multiple observer objects into a single entity, enabling them to be managed and used collectively.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ConfigObserver","page":"Reference","title":"GreenFunctionMonteCarlo.ConfigObserver","text":"ConfigObserver(filename, config::AbstractConfig{T,N}, NSteps::Integer, NWalkers::Integer) where {T,N}\n\nCreates a combined observer that tracks energy, weight, reconfigurations and configurations of the walkers during the Monte Carlo simulation. The observer saves the data to a file with the given filename.\n\nArguments\n\nfilename::String: The name of the file where the configuration data will be saved.\nconfig::AbstractConfig{T,N}: The initial configuration object representing the system state.\nNSteps::Integer: The number of simulation steps to be observed.\nNWalkers::Integer: The number of walkers (or particles) in the simulation.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.ConfigurationObserver","page":"Reference","title":"GreenFunctionMonteCarlo.ConfigurationObserver","text":"struct ConfigurationObserver{T} <: AbstractObserver\n\nSaves the configurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the configurations.\n\nSee Also\n\nObservableAccumulator\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ContinuousTimePropagator","page":"Reference","title":"GreenFunctionMonteCarlo.ContinuousTimePropagator","text":"ContinuousTimePropagator{T<:AbstractFloat} <: AbstractPropagator\n\nA structure representing a imaginary time projection of a trial wavefunction, also referred to as the \"Continuous time limit\". \n\nType Parameters\n\nT<:AbstractFloat: The floating-point type used for numerical computations  (e.g., Float64, Float32).\n\nSupertype\n\nAbstractPropagator: This structure is a subtype of AbstractPropagator,  indicating that it implements the required interface for propagators in the  Green Function Monte Carlo framework.\n\nFields\n\ndτ::T: The time step for the propagation, which is a floating-point value. A small value may be inefficient in exploring the Hilbert space, while a large value will lead to a more unstable propagation. A good starting point is dτ = 0.1.\nw_avg_estimate::T: An estimate of the average weight to reduce floating point errors. Ideally given by the exact ground state energy of the system.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.DiagOperator","page":"Reference","title":"GreenFunctionMonteCarlo.DiagOperator","text":"DiagOperator{F} <: DiagonalOperator\n\nA type that can hold an arbitrary function H_xx = f(x) as a diagonal operator.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.DiagonalOperator","page":"Reference","title":"GreenFunctionMonteCarlo.DiagonalOperator","text":"DiagonalOperator\n\nAn abstract type representing a diagonal operator in the context of Green Function Monte Carlo simulations. A diagonal operator is special in the sense that it will not change the configuration of the system when applied to it and will only return a number.\n\nInterface:\n\n(D::DiagonalOperator)(x) : return the value of the operator applied to the configuration x\n(D::DiagonalOperator)(x, params): return the value of the operator applied to the configuration x with parameters params, which can be used to store buffers.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.EqualWeightSuperposition","page":"Reference","title":"GreenFunctionMonteCarlo.EqualWeightSuperposition","text":"struct EqualWeightSuperposition <: AbstractGuidingFunction\n\nRepresents a guiding function that models an equal weight superposition of states, i.e. ψ(x) = 1 for all x, provided that the configuration x is a valid configuration satisfying all constraints. This structure is a subtype of AbstractGuidingFunction and is used in the context of variational calculations within the Green Function Monte Carlo framework.\n\nSee Also\n\nAbstractGuidingFunction: The abstract type that this struct extends.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.GFMCProblem","page":"Reference","title":"GreenFunctionMonteCarlo.GFMCProblem","text":"struct GFMCProblem{WE<:AbstractWalkerEnsemble, Prop<:AbstractPropagator, GF<:AbstractGuidingFunction, \n                 SFO<:AbstractSignFreeOperator, HS<:AbstractHilbertSpace, PS<:AbstractParallelizationScheme, \n                 RS<:AbstractReconfigurationScheme} <: AbstractGFMCProblem\n\nRepresents a Green's Function Monte Carlo (GFMC) problem with the following type parameters:\n\nWE<:AbstractWalkerEnsemble: The type of the walker ensemble used in the simulation.\nProp<:AbstractPropagator: The propagator responsible for evolving the system.\nGF<:AbstractGuidingFunction: The guiding function used to improve the efficiency of the simulation.\nSFO<:AbstractSignFreeOperator: The operator ensuring sign-free sampling in the simulation, containing only negative elements on the off-diagonal.\nHS<:AbstractHilbertSpace: The Hilbert space in which the problem is defined.\nPS<:AbstractParallelizationScheme: The parallelization scheme used for distributing computation.\nRS<:AbstractReconfigurationScheme: The reconfiguration scheme used to manage walker populations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","page":"Reference","title":"GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","text":"Overview\n\nGreenFunctionMonteCarlo.jl is a Julia package designed for performing Green Function Monte Carlo (GFMC) simulations on lattice models.\n\nPresently, this package treats only Hamiltonians that are free of the sign problem, i.e. whose elements satisfy\n\n\nH_x x leq 0 quad forall x neq x\n\nwhere H_x x is the matrix element of the Hamiltonian between two configurations (spins or bosons) x and x. \n\nUsage:\n\nusing GreenFunctionMonteCarlo, LinearAlgebra\nNSites = 3\nNwalkers = 10\nNSteps = 10\nHilbert = BosonHilbertSpace(NSites, HardCoreConstraint())\nmoves = eachcol(Bool.(I(NSites))) # each move flips a single spin\noffdiagElements = -ones(NSites)\nH = localOperator(eachrow(moves), offdiagElements, DiagOperator(x->0), Hilbert)\n\nproblem = GFMCProblem(BosonConfig(Hilbert), Nwalkers, ContinuousTimePropagator(0.1); logψ = EqualWeightSuperposition(), H, Hilbert)\nObserver = ConfigObserver(BosonConfig(Hilbert), NSteps, Nwalkers) # Observer to measure the energy and configurations\nrunGFMC!(problem, NoObserver(), 100) #run for 100 steps without observing to equilibrate\nrunGFMC!(problem, Observer, NSteps) #run for NSteps steps\n\n\n\n\n\n","category":"module"},{"location":"Reference/#GreenFunctionMonteCarlo.HardCoreConstraint","page":"Reference","title":"GreenFunctionMonteCarlo.HardCoreConstraint","text":"HardCoreConstraint <: AbstractConstraint\n\nA struct representing a hard-core constraint in the system. This constraint  enforces that certain configurations are not allowed, typically used in  bosonic systems to model hard-core interactions where particles cannot  occupy the same state or position.\n\nThis type is a subtype of AbstractConstraint, which serves as a base  for defining various constraints in the system. Useful for simulating spin-1/2 systems.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.InverseMove","page":"Reference","title":"GreenFunctionMonteCarlo.InverseMove","text":"struct InverseMove{T<:AbstractMove} <: AbstractMove\n\nA type representing an inverse move in a Monte Carlo simulation. This type is parameterized by T, which must be a subtype of AbstractMove. The InverseMove struct is used to encapsulate the concept of an inverse operation corresponding to a given move in the simulation.\n\nParameters\n\nT: A subtype of AbstractMove that specifies the type of move for which this struct represents the inverse.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.Jastrow","page":"Reference","title":"GreenFunctionMonteCarlo.Jastrow","text":"struct Jastrow{T<:Real} <: AbstractGuidingFunction\n\nA structure representing the Jastrow factor in a variational Monte Carlo simulation. This function strikes a good balance between accuracy and computational efficiency in the context of Green Function Monte Carlo. log(ψ(x)) = sum_i m_i x_i + frac12sum_ij v_ij x_i x_j\n\nType Parameters\n\nT<:Real: The numeric type used for the parameters of the Jastrow factor  (e.g., Float64, Float32).\n\nUsage\n\nlogψ = Jastrow(N,Float64) # Create a Jastrow factor for N sites with parameters of type Float64. logψ = Jastrow(conf,Float64) # Create a Jastrow factor for configurations similar to conf.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NaiveFunction","page":"Reference","title":"GreenFunctionMonteCarlo.NaiveFunction","text":"provides a naive wrapper for a guiding function which does not use any buffer. Useful for debugging and testing\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NoLogger","page":"Reference","title":"GreenFunctionMonteCarlo.NoLogger","text":"NoLogger <: AbstractLogger\n\nA placeholder implementation that does not perform any logging.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NoObserver","page":"Reference","title":"GreenFunctionMonteCarlo.NoObserver","text":"NoObserver <: AbstractObserver\n\nAn observer type that does not save anything. Can be used to evolve the system in the most efficient way, i.e. for equilibration.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ObservableAccumulator","page":"Reference","title":"GreenFunctionMonteCarlo.ObservableAccumulator","text":"ObservableAccumulator{ObsType<:AbstractObservable, T_high<:AbstractFloat, T_low<:Real}\n\nAn accumulator for observables in Monte Carlo simulations. This struct is designed to collect and process measurements of a given observable type during the simulation, supporting both high-precision (T_high) and lower-precision (T_low) data types.\n\nType Parameters\n\nObsType<:AbstractObservable: The type of observable being accumulated.\nT_high<:AbstractFloat: The floating-point type used for high-precision accumulation (e.g., Float64).\nT_low<:Real: The type used for lower-precision to speed-up calculations (typically Float32).\n\nDescription\n\nObservableAccumulator is typically used as part of the observer pattern in Monte Carlo simulations, where it collects measurements of observables at each step and provides methods for statistical analysis, such as computing averages and variances.\n\nSee Also\n\nBasicAccumulator\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.OneBodyDiagOperator","page":"Reference","title":"GreenFunctionMonteCarlo.OneBodyDiagOperator","text":"OneBodyDiagOperator{T<:AbstractVector} <: DiagonalOperator\n\nA type that represents arbitrary diagonal one-body interactions H_xx = sum_{i} m_i x_i\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ProblemEnsemble","page":"Reference","title":"GreenFunctionMonteCarlo.ProblemEnsemble","text":"ProblemEnsemble{P<:AbstractGFMCProblem} <: AbstractGFMCProblem\n\nRun multiple GFMC problems in parallel. Useful to estimate errors.\n\nUsage example:\n\nP = ProblemEnsemble([GFMCProblem1, GFMCProblem2, ...])\n\nproblems = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for _ in 1:10])\n\nObservers = [ConfigObserver(\"output_$i.h5\",startConfig, NSteps, NWalkers) for i in 1:10] #note that each observer must have its own file\n\nrunGFMC!(problems, NoObserver(),100) #equilibrate\nrunGFMC!(problems, Observers)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ProgressBarLogger","page":"Reference","title":"GreenFunctionMonteCarlo.ProgressBarLogger","text":"ProgressBarLogger(; kwargs...)\n\nCreates a progress bar logger with customizable update intervals and additional options.\n\nArguments\n\nkwargs...: Additional keyword arguments to customize the behavior of the progress bar logger. See GreenFunctionMonteCarlo.ProgressMeter.Progress for more details.\n\nReturns\n\nA progress bar logger instance that can be used to track and display progress in a task.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.SimpleLogger","page":"Reference","title":"GreenFunctionMonteCarlo.SimpleLogger","text":"struct SimpleLogger <: AbstractLogger\n\nA simple logger implementation that inherits from AbstractLogger.\n\nFields\n\nn_report::Int: The number of steps in the log report.\n\nThis logger can be used to control and manage logging behavior in a straightforward manner.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.TwoBodyDiagOperator","page":"Reference","title":"GreenFunctionMonteCarlo.TwoBodyDiagOperator","text":"TwoBodyDiagOperator{T<:AbstractMatrix} <: DiagonalOperator\n\nA type that represents arbitrary diagonal two-body interactions H_xx = sum_{i,j} v_ij x_i x_j\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.WalkerAVGObserver","page":"Reference","title":"GreenFunctionMonteCarlo.WalkerAVGObserver","text":"struct WalkerAVGObserver{T} <: AbstractObserver\n\nSaves the average of configurations over all walkers during the Monte Carlo simulation at each step.\n\nType Parameters\n\nT: Data type for the configurations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ZeroDiagOperator","page":"Reference","title":"GreenFunctionMonteCarlo.ZeroDiagOperator","text":"ZeroDiagOperator <: DiagonalOperator\n\nA struct representing a diagonal operator H_xx = 0\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.allocate_GWF_buffers","page":"Reference","title":"GreenFunctionMonteCarlo.allocate_GWF_buffers","text":"allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer, x)\n\nAllocates a specified number of guiding wave function (GWF) buffers.\n\nArguments\n\nlogψ::AbstractGuidingFunction: The guiding function for which the buffers are being allocated.\nNBuffers::Integer: The number of buffers to allocate.\nx: An exemplary configuration\n\nReturns\n\nAn array filled with NBuffers instances of AbstractGuidingFunctionBuffer. Defaults to an array of NotImplementedBuffer instances.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.apply!","page":"Reference","title":"GreenFunctionMonteCarlo.apply!","text":"apply!(x::AbstractConfig, move::AbstractMove)\n\nThrows a MethodError indicating that the apply! function has not been implemented for the given AbstractConfig type and move.\n\nArguments\n\nx::AbstractConfig: An instance of a type that is a subtype of AbstractConfig.\nmove::AbstractMove: A move or operation to be applied to the configuration x.\n\nThrows\n\nMethodError: Always thrown to indicate that the method needs to be implemented for specific subtypes of AbstractConfig.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.continuos_time_propagation!","page":"Reference","title":"GreenFunctionMonteCarlo.continuos_time_propagation!","text":"continuos_time_propagation!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, dτ::Real, parallelization::MultiThreaded, RNG::Random.AbstractRNG = Random.default_rng())\n\nPerform continuous time propagation on a walker ensemble for a fixed time step dτ.\n\nArguments\n\nWE::AbstractWalkerEnsemble: The ensemble of walkers to be propagated.\nH::AbstractSignFreeOperator: The Hamiltonian operator used for propagation.\nlogψ::AbstractGuidingFunction: The guiding function for the propagation.\nHilbert::AbstractHilbertSpace: The Hilbert space in which the propagation occurs.\ndτ::Real: The time step for the propagation.\nw_avg_estimate::Real: An estimate of the average weight.\nparallelization::MultiThreaded: Parallelization settings for the propagation.\nRNG::Random.AbstractRNG: The random number generator to be used (default is Random.default_rng()).\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.data_bunch","page":"Reference","title":"GreenFunctionMonteCarlo.data_bunch","text":"data_bunch(data::AbstractVector{T}) where T\n\nGroups or \"bunches\" the input data vector into bins for statistical autocorrelation analysis. \n\nArguments\n\ndata::AbstractVector{T}: The input data vector to be binned.\n\nReturns\n\nA binned version of the input data, typically as a vector or collection of bins, depending on the implementation.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.estimate_weights_continuousTime!","page":"Reference","title":"GreenFunctionMonteCarlo.estimate_weights_continuousTime!","text":"estimate_weights_continuousTime!(prob; Nepochs=5, Nsamples=100, mProj=50)\n\nEstimate weights in a continuous-time Monte Carlo simulation. Useful for reducing the floating point errors for accumulators. The results may be passed to  ContinuousTimePropagator(tau,w_avg_estimate) and BasicAccumulator(args...;weight_normalization)\n\nArguments\n\nprob: The problem instance or data structure containing the simulation setup.\nNepochs: (Optional) Number of epochs to run the estimation. Default is 5.\nNsamples: (Optional) Number of samples per epoch. Default is 100.\nmProj: (Optional) Number of projection steps or iterations. Default is 50.\n\nDescription\n\nThis function performs an in-place estimation of weights for a given problem using a continuous-time Monte Carlo approach. The process iterates over a specified number of epochs, drawing samples and projecting as configured by the keyword arguments.\n\nReturns\n\nModifies prob in place which helps to equilibrate\nReturns a rough estimate of the mean total weight and CT.wavgestimate.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.fulfills_constraint","page":"Reference","title":"GreenFunctionMonteCarlo.fulfills_constraint","text":"fulfills_constraint(x::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if the given configuration x satisfies the constraint of the specified HilbertSpace.\n\nArguments\n\nx::AbstractArray: The configuration to be checked.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space whose constraint need to be satisfied.\n\nReturns\n\nBool: true if the configuration satisfies the constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.getEnergies","page":"Reference","title":"GreenFunctionMonteCarlo.getEnergies","text":"getEnergies(weights, localEnergies, PMax; kwargs...)\n\nCompute the energies based on the provided weights and local energies, for the projection steps p = 0,1,2,...,PMax.\n\nArguments\n\nweights: A collection of weights associated with the samples.\nlocalEnergies: A collection of local energy values corresponding to the samples.\nPMax: An integer indicating the maximum projection order.\n\nKeyword arguments\n\nGnp: optionally provided precomputed normalized accumulated weights.\n\nReturns\n\nReturns the computed energies based on the input parameters.\n\nNotes\n\nEnsure that the dimensions of weights and localEnergies are compatible.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.get_energy_from_accumulator_bunching","page":"Reference","title":"GreenFunctionMonteCarlo.get_energy_from_accumulator_bunching","text":"get_energy_from_accumulator_bunching(Observables::BasicAccumulator, n_bunch::Integer; kwargs...)\n\nCompute the energy by bunching together observable accumulators.\n\nArguments\n\nObservables::BasicAccumulator: The accumulator containing observable measurements.\nn_bunch::Integer: The number of bunches to divide the data into for statistical analysis. For no bunching, pass n_bunch=1.\nkwargs...: Additional keyword arguments for customization of the chunking process, such as size or split.\n\nReturns\n\nThe computed energy, possibly with statistical error estimates depending on implementation.\n\nDescription\n\nThis function processes the accumulated observables by grouping (bunching) the data into n_bunch groups. It then calculates the energy, which can be used for error analysis or to reduce autocorrelation effects in Monte Carlo simulations.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.get_move","page":"Reference","title":"GreenFunctionMonteCarlo.get_move","text":"get_move(O::AbstractOperator,idx::Integer)\n\nReturn the move associated with the operator O at index idx. \n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.get_offdiagonal_elements","page":"Reference","title":"GreenFunctionMonteCarlo.get_offdiagonal_elements","text":"get_offdiagonal_elements(O::AbstractSignFreeOperator)\n\nReturn the weights associated with an AbstractSignFreeOperator object O. \n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.isapplicable","page":"Reference","title":"GreenFunctionMonteCarlo.isapplicable","text":"isapplicable(x::AbstractConfig, move::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if a given move is applicable to the current configuration within a specified Hilbert space.\n\nArguments\n\nx::AbstractConfig: The current configuration.\nmove::AbstractMove: The proposed move to be applied.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space in which the configuration and move are defined.\n\nReturns\n\nBool: true if the move is applicable, false otherwise.\n\nDefaults to applying the move to the configuration, checking if the constraints are satisfied, and then reverting the move.\n\nMake sure to implement this function for specific subtypes of AbstractConfig and AbstractHilbertSpace to ensure optimal performance. See also isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint).\n\n\n\n\n\nisapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint) -> Bool\n\nCheck if a given move is applicable to a configuration under a specified constraint.\n\nArguments\n\nx::AbstractConfig: The configuration to which the move will be applied.\nmove::AbstractMove: The move that is being checked for applicability.\nconstraint::AbstractConstraint: The constraint that must be satisfied for the move to be applicable.\n\nReturns\n\nBool: true if the move is applicable to the configuration under the given constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.minimizeReconfiguration!","page":"Reference","title":"GreenFunctionMonteCarlo.minimizeReconfiguration!","text":"minimizeReconfiguration!(list)\n\ngiven a list of reconfiguration indices, minimizes the number of reconfigurations by swapping elements in the list. Each walker that survives a reconfiguration step remains unchanged while walkers that are killed get assigned to a new index.\n\nArguments\n\nlist: A collection (e.g., an array) that will be reconfigured in-place.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.pre_move_affect!","page":"Reference","title":"GreenFunctionMonteCarlo.pre_move_affect!","text":"Updates the guiding function buffer before any move is applied.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.propagateWalkers!","page":"Reference","title":"GreenFunctionMonteCarlo.propagateWalkers!","text":"Propagates walker ensemble X using a collection of moves according to the rules specified by the propagator P. \n\nUsage:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.reconfigurateWalkers!","page":"Reference","title":"GreenFunctionMonteCarlo.reconfigurateWalkers!","text":"Performs an efficient reconfiguration of walkers. This reconfiguration will not remove walkers if they all have the same weight, which increases the efficiency as more walkers can contribute to the average.\n\nMatteo Calandra Buonaura and Sandro Sorella Phys. Rev. B 57, 11446 (1998)\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers to be reconfigured.\nreconfigurationList: A list of indices that will be reconfigured.\nrng::Random.AbstractRNG: The random number generator to be used.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.runGFMC!","page":"Reference","title":"GreenFunctionMonteCarlo.runGFMC!","text":"runGFMC!(Walkers::AbstractWalkerEnsemble, Observables::AbstractObserver, reconfiguration::AbstractReconfigurationScheme, \n         range, propagator::AbstractPropagator, logψ::AbstractGuidingFunction, H::AbstractSignFreeOperator, \n         Hilbert::AbstractHilbertSpace, parallelizer::AbstractParallelizationScheme, logger::AbstractLogger, RNG::Random.AbstractRNG)\n\nRuns the Green Function Monte Carlo (GFMC) simulation for a given system.\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers representing the quantum state.\nObservables::AbstractObserver: The observer object used to measure physical quantities during the simulation.\nreconfiguration::AbstractReconfigurationScheme: The scheme used to reconfigure the walker ensemble to maintain population control.\nrange: The range of iterations or time steps for the simulation.\npropagator::AbstractPropagator: The propagator used to evolve the walkers.\nlogψ::AbstractGuidingFunction: The guiding function (logarithmic form) used for importance sampling.\nH::AbstractSignFreeOperator: The Hamiltonian operator of the system, assumed to be sign-free.\nHilbert::AbstractHilbertSpace: The Hilbert space on which the system is defined.\nparallelizer::AbstractParallelizationScheme: The parallelization scheme used to distribute computation across resources.\nlogger::AbstractLogger: The logger object used to record simulation progress.\nRNG::Random.AbstractRNG: The random number generator used for stochastic processes in the simulation.\n\nDescription\n\nThis function performs the GFMC simulation by evolving the walker ensemble using the provided propagator and guiding function. It measures observables diagonal in the computational Basis at each step and applies reconfiguration to control the walker population. The simulation is parallelized according to the specified parallelization scheme.\n\nNotes\n\nThe function modifies the Walkers object in place.\nEnsure that all input objects are properly initialized before calling this function.\n\n\n\n\n\nrunGFMC!(prob::GFMCProblem, Observables::AbstractObserver, range; \n         logger = default_logger(), rng = Random.default_rng(), \n         reconfiguration = prob.reconfiguration, Propagator = prob.Propagator, \n         logψ = prob.logψ, H = prob.H, Hilbert = prob.Hilbert, \n         parallelization = prob.parallelization)\n\nRun the Green's Function Monte Carlo (GFMC) simulation for the given problem.\n\nArguments\n\nprob::GFMCProblem: The GFMC problem instance containing the system configuration and parameters.\nObservables::AbstractObserver: An observer object to track and record observables during the simulation.\nrange: Integer or range: The range of iterations or steps over which the simulation will be performed.\n\nKeyword Arguments to override default values\n\nlogger: (Optional) A logger instance for logging simulation progress. Defaults to default_logger(). Use NoLogger() or nothing to disable logging.\nrng: (Optional) A random number generator to ensure reproducibility. Defaults to Random.default_rng().\nreconfiguration: (Optional) The reconfiguration method to be used during the simulation. Defaults to prob.reconfiguration.\nPropagator: (Optional) The propagator function for the simulation. Defaults to prob.Propagator.\nlogψ: (Optional) The logarithm of the wavefunction. Defaults to prob.logψ.\nH: (Optional) The Hamiltonian operator. Defaults to prob.H.\nHilbert: (Optional) The Hilbert space of the system. Defaults to prob.Hilbert.\nparallelization: (Optional) The parallelization strategy for the simulation. Defaults to prob.parallelization.\n\nReturns\n\nThis function modifies the prob and Observables in place to reflect the results of the simulation.\n\nNotes\n\nEnsure that the prob and Observables are properly initialized before calling this function.\nIf range is provided as an integer, it will be converted to a range 1:range.\nIf logger is nothing, it will default to NoLogger().\n\n\n\n\n\n","category":"function"},{"location":"Example_transverseFieldIsing/#Example:-1D-Transverse-Field-Ising-Model","page":"Tutorial","title":"Example: 1D Transverse Field Ising Model","text":"","category":"section"},{"location":"Example_transverseFieldIsing/#Defining-the-Hamiltonian","page":"Tutorial","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"The transverse field Ising model is a quantum spin model that exhibits a quantum phase transition. The Hamiltonian for the model is given by:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"H = -J sum_i^L sigma_i^z sigma_i+1^z - h sum^L_i sigma_i^x","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"where:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"L is the number of spins.\nJ is the interaction strength between neighboring spins.\nh is the transverse field strength.\nsigma^z and sigma^x are Pauli matrices.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"At the critical point h=1, the energy for open boundary conditions is given by:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"E_crit = 1 - cosec left(fracpi2(2L+1)right)","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Below is an example of how to simulate the transverse field Ising model using GreenFunctionMonteCarlo.jl:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"First, we implement our Hamiltonian. Since our problem is equivalent to a hardcore boson problem, we represent our spin configurations by Booleans for optimal performance.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"using GreenFunctionMonteCarlo\n\nσz(n::Bool) = (1 - 2 * n)\nσz(i, conf::AbstractArray) = σz(conf[i])\n\nfunction transverse_field_ising(Nsites, h, J; periodic = false)\n    Hilbert = BosonHilbertSpace(Nsites, HardCoreConstraint())\n\n    moves = [Bool[0 for _ in 1:Nsites] for _ in 1:Nsites]\n    offdiagElements = zeros(Float64, Nsites)\n\n    for i in eachindex(moves)\n        moves[i][i] = true\n        offdiagElements[i] = -h\n    end\n\n    function Hxx(conf)\n        E = -J * sum(σz(i, conf) * σz(i + 1, conf) for i in eachindex(conf)[1:end-1])\n        if periodic\n            E += -J * σz(Nsites, conf) * σz(1, conf)\n        end\n        return E\n    end\n\n    H = localOperator(moves, offdiagElements, DiagOperator(Hxx), Hilbert)\n    return (; Hilbert, H)\nend\n\n# Define parameters\nJ = 1.0       # Interaction strength\nh = 1.0       # Transverse field strength\nlattice_size = 4  # Number of spins\nperiodic = false  # No periodic boundary conditions\n# Define the Hamiltonian\n(;Hilbert,H) = transverse_field_ising(lattice_size, h, J; periodic)","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"The Hamiltonian is split into a diagonal and an offdiagonal part. The diagonal H_xx can be an arbitray function of the configuration x. The offdiagonal is given by the moves and offdiagElements arrays. The moves array contains the indices of the spins that are flipped, while the offdiagElements array contains the corresponding weights for each move.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThe moves can also be given by Integers, i.e. Int8[0,0,...,-1,1,0,...,0] for a term sigma_i^- sigma_i+1^+. This will be slower, but allows for more complex moves.","category":"page"},{"location":"Example_transverseFieldIsing/#Running-the-Simulation","page":"Tutorial","title":"Running the Simulation","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"We now proceed to solve the Hamiltonian. It is instructive to consider a single walker first. As a guiding wavefunction, we use the simplest one, an equal weight superposition of all configurations psi(x) =1.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"NSteps = 500  # Number of Monte Carlo steps\nNStepsEquil = 30  # Number of Monte Carlo steps for equilibration\nNWalkers = 1  # Number of walkers\ndtau = 0.1    # imaginary time propagation step\n\nstartConfig = BosonConfig(Hilbert) # creates an initial configuration where all occupation numbers are 0\n\nproblem = GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ = EqualWeightSuperposition(), H, Hilbert)\nObserver = ConfigObserver(startConfig, NSteps, NWalkers) # Observer to measure the energy and configurations \nrunGFMC!(problem, NoObserver(), NStepsEquil) #run for NStepsEquil steps without observing to equilibrate\nrunGFMC!(problem, Observer, NSteps) #run for NSteps steps","category":"page"},{"location":"Example_transverseFieldIsing/#Evaluating-the-Results","page":"Tutorial","title":"Evaluating the Results","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Let's see the results. For open boundary conditions at the critical point h=J, we may compare to the exact solution. ","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie, Statistics, Random\nRandom.seed!(123) # for reproducibility\nfunction E_critPoint_exact(L, h=1, periodic=false)\n    (!periodic && h==1) || return NaN \n    \n    return 1 - csc(pi / (2 * (2 * L + 1)))\nend\n\nMaxProjection = 40\nenergies = getEnergies(Observer, MaxProjection) \ntau = (0:MaxProjection-1) * dtau\n\nlet \n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"Energy$$\")\n\n    lines!(ax, tau, energies, label=L\"$\\psi(x)=1$\")\n\n    hlines!(ax, E_critPoint_exact(lattice_size,h,periodic), color=:black, label=L\"Exact$$\", linestyle=:dash)\n\n    axislegend(ax, position=:rt)\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Run the GFMC simulation a few times (with different seeds) and see what happens:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"At tau=0 (for a single walker!), we will always obtain the variational energy of the guiding wavefunction.\nThe energy initially decreases with the number of projections.\nHowever, for larger tau, the energy is strongly affected by statistical fluctuations. It may either increase or go below the exact energy.\nWe may quantify this statistical error by looking at the standard deviation of the energy upon performing several runs (see below).\nProvided a large enough tau, such that the imaginary time projection is converged, the energy will be within the statistical error of the exact energy.","category":"page"},{"location":"Example_transverseFieldIsing/#Using-Variational-Wavefunctions","page":"Tutorial","title":"Using Variational Wavefunctions","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"The issue of errorbars growing exponentially with tau can be significantly alleviated by using more Walkers, i.e. setting NWalkers = 10 in the example above, or by using a more sophisticated guiding wavefunction. For example, it is easy to implement a short ranged Jastrow wavefunction which correlates nearest neighbors spins.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nYou must always implement the logarithm of the wavefunction, i.e. log psi(x).","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"function ShortRangeJastrow(x)\n    res = 0.\n    for i in eachindex(x)[1:end-1]\n        res += 0.5x[i]*x[i+1]\n    end\n    return res\nend\nlogψ = NaiveFunction(ShortRangeJastrow)\nNWalkers = 10\nP = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for i in 1:10])\nObservers_jastrow = [ConfigObserver(startConfig, NSteps, NWalkers) for _ in 1:10]\n\nrunGFMC!(P, NoObserver(),200,logger=nothing) #equilibrate\nrunGFMC!(P, Observers_jastrow,NSteps,logger=nothing)\n\nenergies_jastrow = [getEnergies(Observer, MaxProjection) for Observer in Observers_jastrow]\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"Energy$$\")\n\n    lines!(ax, tau, energies, label=L\"$\\psi(x)=1,\\ N_w=1$\")\n\n    lines!(ax, tau, mean(energies_jastrow), label=L\"shortrange Jastrow $N_w=%$NWalkers$\")\n    band!(ax, tau, mean(energies_jastrow) - std(energies_jastrow), mean(energies_jastrow) + std(energies_jastrow), color=(:green, 0.2))\n\n    hlines!(ax, E_critPoint_exact(lattice_size), color=:black, label=L\"Exact$$\", linestyle=:dash)\n\n    axislegend(ax, position=:rt)\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"tip: Tip\nThere is already an efficient implementation of the Jastrow function. Simply use it as:vij_jastrow = zeros(Float32,lattice_size,lattice_size)\nfor i in axes(vij_jastrow, 1)[1:end-1]\n    vij_jastrow[i,i+1]=vij_jastrow[i+1,i] = 0.5\nend\n\nlogψJastrow = Jastrow(\n    zeros(Float32,lattice_size),\n    vij_jastrow,\n)It is advised to use variational Monte Carlo to optimize a variational wavefunction before using it in GFMC. A particularly useful package is Netket, which may be called from Julia via PyCall.","category":"page"},{"location":"Example_transverseFieldIsing/#Observables-diagonal-in-the-computational-basis","page":"Tutorial","title":"Observables diagonal in the computational basis","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Observables which are diagonal in the computational basis (i.e. they can be expressed as a function of the occupation numbers) are simple to determine. Using the ConfigObserver, which records the configuration of the walkers at each step, we can compute them cheaply after the simulation.  To do this, we only need to use the function getObs_diagonal. Let's consider the average occupation number as an example.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"mProj = 40  # Number of projection steps\nObservable = OccupationNumber(lattice_size)\n\nn_avg = [stack(getObs_diagonal(O,Observable,1:mProj)) for O in Observers_jastrow]\n\nn_avg_mean = mean(n_avg)\nn_avg_std = std(n_avg)\n\nlet \n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"$\\langle S^z_i\\rangle$\")\n    tau =( 0:mProj-1) * dtau\n    for i in 1:lattice_size\n        lines!(ax, tau, n_avg_mean[i,:])\n        band!(ax, tau, n_avg_mean[i,:] - n_avg_std[i,:], n_avg_mean[i,:] + n_avg_std[i,:], alpha = 0.5)\n    end\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Here, OccupationNumber is a pre-defined observable. However, it is relatively simple to implement your own observables by defining a new subtype of AbstractObservable. As an example lets try to compute langle S^z_i S^z_j rangle in a simple way.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"struct SpinCorrelations{T<:Real} <: AbstractObservable\n    ObservableBuffer::Matrix{T}\nend\nSpinCorrelations(Nsites) = SpinCorrelations(zeros(Nsites,Nsites))\n\nBase.copy(O::SpinCorrelations) = SpinCorrelations(copy(O.ObservableBuffer))\nGreenFunctionMonteCarlo.obs(O::SpinCorrelations) = O.ObservableBuffer\nfunction (O::SpinCorrelations)(out,config)\n    for i in axes(out,1)\n        for j in axes(out,2)\n            out[i,j] = σz(i,config) * σz(j,config)\n        end\n    end\n    return out\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Key here is the function (O::My_new_OccupationNumber)(out,config). Given a configuration config, it computes the estimate observable and stores it in a pre-allocated buffer out.  Also note the defintion of GreenFunctionMonteCarlo.obs(O::My_new_OccupationNumber), which returns the buffer that is used to store the observable.  Now we can use this observable in the same way as the OccupationNumber above:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Observable = SpinCorrelations(lattice_size)\nCorrs = [stack(getObs_diagonal(O,Observable,1:mProj)) for O in Observers_jastrow]\n\nCorr_mean = mean(Corrs)\nCorr_std = std(Corrs)\n\nlet \n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"$\\langle S^z_i\\rangle$\")\n    tau =( 0:mProj-1) * dtau\n    \n    i = 2\n    for j in 1:lattice_size\n        lines!(ax, tau, Corr_mean[i,j,:])\n        band!(ax, tau, Corr_mean[i,j,:] - Corr_std[i,j,:], Corr_mean[i,j,:] + Corr_std[i,j,:], alpha = 0.5)\n    end\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"Note that we left quite some room to improve performance here. For instance, we do not actually have to compute the full matrix of correlations, but only the upper triangle. ","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Tutorial","title":"Tutorial","text":"tip: Tip\nWhile the approach above is very convenient, for big simulations, it may not be feasible to store all configurations as the output file may become too large. For this case, it is also possible to use accumulators, such as BasicAccumulator and ObservableAccumulator. Accumulators compute the imaginary time projection of the observable at every step of the simulation, thereby saving a lot of storage. BasicAccumulator contains all the essential information to allow for projection during the run, while ObservableAccumulator may be used to compute observables.  To combine several accumulators, you can use CombinedObserver. ","category":"page"},{"location":"Contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"#GreenFunctionMonteCarlo","page":"Overview","title":"GreenFunctionMonteCarlo","text":"","category":"section"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"GreenFunctionMonteCarlo.jl is a Julia package designed for performing Green Function Monte Carlo (GFMC) simulations on lattice models.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Presently, this package treats only Hamiltonians that are free of the sign problem, i.e. whose elements satisfy","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"\nH_x x leq 0 quad forall x neq x","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where H_x x is the matrix element of the Hamiltonian between two configurations (spins or bosons) x and x. ","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To install the package, use the Julia package manager:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.add(url = \"https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl.git\")","category":"page"},{"location":"#Quick-usage-example:","page":"Overview","title":"Quick usage example:","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"using GreenFunctionMonteCarlo, LinearAlgebraö\nNSites = 3\nNwalkers = 10\nNSteps = 10\nHilbert = BosonHilbertSpace(NSites, HardCoreConstraint())\nmoves = Bool.(I(NSites)) # each move flips a single spin\noffdiagElements = -ones(NSites)\nH = localOperator(eachrow(moves), offdiagElements, DiagOperator(x->0), Hilbert)\n\nproblem = GFMCProblem(BosonConfig(Hilbert), Nwalkers, ContinuousTimePropagator(0.1); logψ = EqualWeightSuperposition(), H, Hilbert)\nObserver = ConfigObserver(BosonConfig(Hilbert), NSteps, Nwalkers) # Observer to measure the energy and configurations\nrunGFMC!(problem, NoObserver(), 100) #run for 100 steps without observing to equilibrate\nrunGFMC!(problem, Observer, NSteps) #run for NSteps steps","category":"page"},{"location":"#Contributing","page":"Overview","title":"Contributing","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Contributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.","category":"page"},{"location":"#License","page":"Overview","title":"License","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This project is licensed under the MIT License. See the LICENSE file for details.","category":"page"},{"location":"#References:","page":"Overview","title":"References:","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"[1] Buonaura, M. & Sorella, S. Green's function Monte Carlo method for lattice fermions. Phys. Rev. B 57, 11446 (1998).\n[2] Becca, F. & Sorella, S. Quantum Monte Carlo Approaches for Correlated Systems. Cambridge University Press; 2017.","category":"page"}]
}
