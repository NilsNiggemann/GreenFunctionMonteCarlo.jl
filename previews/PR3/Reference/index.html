<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GreenFunctionMonteCarlo.jl</title><meta name="title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta property="og:title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta property="twitter:title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta name="description" content="Documentation for GreenFunctionMonteCarlo.jl."/><meta property="og:description" content="Documentation for GreenFunctionMonteCarlo.jl."/><meta property="twitter:description" content="Documentation for GreenFunctionMonteCarlo.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GreenFunctionMonteCarlo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../Contents/">Contents</a></li><li><a class="tocitem" href="../Example_transverseFieldIsing/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/master/docs/src/Reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractConfig" href="#GreenFunctionMonteCarlo.AbstractConfig"><code>GreenFunctionMonteCarlo.AbstractConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConfig{T,N}</code></pre><p>An abstract type that represents a configuration (i.e. spins, bosons on a lattice).  This type is a subtype of <code>AbstractArray{T,N}</code>.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: The type of the elements in the configuration.</li><li><code>N</code>: The number of dimensions of the configuration.</li></ul><p><strong>Interface</strong></p><ul><li><code>Base.parent(x::AbstractConfig)</code>: return the parent array</li><li><code>Base.copy(x::AbstractConfig)</code>: create a full copy of the configuration</li><li><code>apply!(x::AbstractConfig, move::Any)</code>: apply a move to the configuration</li><li><code>fulfills_constraints(x::AbstractConfig, HilbertSpace::AbstractHilbertSpace)</code>: check if the configuration satisfies the constraints of the Hilbert space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractConfig.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractConstraint" href="#GreenFunctionMonteCarlo.AbstractConstraint"><code>GreenFunctionMonteCarlo.AbstractConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConstraint</code></pre><p>An abstract type representing a constraint in the context of a Hilbert space.</p><p><strong>Interface</strong></p><ul><li><code>(c)(x::AbstractArray)</code>: Check if the configuration <code>x</code> satisfies the constraint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractConstraint.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractDiagObservable" href="#GreenFunctionMonteCarlo.AbstractDiagObservable"><code>GreenFunctionMonteCarlo.AbstractDiagObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for observables which are diagonal in the computational basis and may be measured for free in GFMC. An observable must be a function that takes a configuration and returns an array.</p><p><strong>Interface:</strong></p><ul><li><code>obs(::O)</code> returns the buffer array for the output of the observable.</li><li><code>O(out,Conf)</code>: Writes the observable for the given configuration to the preallocated array <code>out</code>. Returns out.</li><li><code>Base.copy(O::O)</code>: Returns a copy of the observable.</li></ul><p>If no preallocated array is given, the observable defaults to using the buffer array <code>obs(O)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractObserver.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGFMCProblem" href="#GreenFunctionMonteCarlo.AbstractGFMCProblem"><code>GreenFunctionMonteCarlo.AbstractGFMCProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Abstract type for GFMC problems.</code></pre><p><strong>Interface:</strong></p><ul><li><code>runGFMC!(problem::AbstractGFMCProblem,args...;kwargs...)</code>: Run the GFMC algorithm for the given problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractGFMCProblem.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGuidingFunction" href="#GreenFunctionMonteCarlo.AbstractGuidingFunction"><code>GreenFunctionMonteCarlo.AbstractGuidingFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGuidingFunction</code></pre><p>An abstract type for all guiding function implementations in Green Function Monte Carlo. Subtypes of this correspond to implementations of concrete guiding functions, particularly variational wavefunctions. For optimal performance, it is recommended to implement the function log<em>psi</em>diff! for the specific guiding function type.</p><p><strong>Interface</strong></p><ul><li><code>logψ(x::AbstractArray)</code>: return the logarithm of the guiding function evaluated at the configuration <code>x</code>.</li><li><code>logψ(x::AbstractArray, H::AbstractHilbertSpace)</code>: return the logarithm of the guiding function evaluated at the configuration <code>x</code> in the specified <code>HilbertSpace</code>.</li><li><code>log_psi_diff(x::AbstractArray, dx::AbstractArray, logψ::AbstractGuidingFunction, Buffer::AbstractGuidingFunctionBuffer, Hilbert::AbstractHilbertSpace)</code>: return the logarithm of the ratio of the guiding function evaluated at the configuration <code>x</code> and <code>x+dx</code> in the specified <code>HilbertSpace</code>. Returns <code>-Inf</code> if the move is not applicable.</li><li><code>get_params(logψ::AbstractGuidingFunction)</code>: return the parameters of the guiding function as a linear Array. It is recommended to use RecursiveArrayTools.jl for this purpose.</li></ul><p><strong>Interface (optional)</strong></p><ul><li><code>allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer)</code>: allocate NBuffers instances of a buffer for the guiding function. Defaults to an array of EmptyGWFBuffer instances.</li><li><code>compute_GWF_buffer!(Buffer::AbstractGuidingFunctionBuffer, logψ::AbstractGuidingFunction, x)</code>: compute the full buffer for the guiding function at the configuration <code>x</code>. </li><li><code>pre_move_affect!(Buffer::AbstractGuidingFunctionBuffer, x, moves, logψ::AbstractGuidingFunction)</code>: perform any necessary operations before computing ratios ψx´_ψx.</li><li><code>post_move_affect!(Buffer::AbstractGuidingFunctionBuffer, x, dx, logψ::AbstractGuidingFunction)</code>: perform any necessary operations after the move is applied.</li><li><code>HDF5.h5write(file::AbstractString, name::AbstractString, logψ::AbstractGuidingFunction)</code>: write the guiding function to an HDF5 file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractGuidingFunctions.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer" href="#GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer"><code>GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGuidingFunctionBuffer</code></pre><p>An abstract type that serves as a base for defining guiding function buffer structures. </p><p><strong>Interface</strong></p><ul><li><code>setBuffer!(BA::AbstractGuidingFunctionBuffer, BB::AbstractGuidingFunctionBuffer)</code>: set the buffer <code>BA</code> to the values of the buffer <code>BB</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractGuidingFunctions.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractHilbertSpace" href="#GreenFunctionMonteCarlo.AbstractHilbertSpace"><code>GreenFunctionMonteCarlo.AbstractHilbertSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractHilbertSpace</code></pre><p>An abstract type representing a Hilbert space. This type serves as a base for defining various specific Hilbert spaces used in the project. Generally, a hilbert space should be defined by the number of sites, the number of local degrees of freedom (i.e. spin), and the constraint that the configurations must satisfy. </p><p><strong>Interface</strong></p><ul><li><code>constraint(HilbertSpace::AbstractHilbertSpace)</code>: Return the constraint that the configurations in the Hilbert space must satisfy.</li><li><code>Base.size(HilbertSpace::AbstractHilbertSpace)</code>: Return the size of a config in the Hilbert space.</li></ul><p><strong>Interface (optional)</strong></p><ul><li><code>fulfills_constraint(x,HilbertSpace::AbstractHilbertSpace)</code>: Check if the given configuration <code>x</code> satisfies the constraint of the specified <code>HilbertSpace</code>. Defaults to <code>constraint(HilbertSpace)(x)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractHilbertSpace.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractMove" href="#GreenFunctionMonteCarlo.AbstractMove"><code>GreenFunctionMonteCarlo.AbstractMove</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMove</code></pre><p>Abstract type representing a move, i.e. an operation that changes a configuration x to a new configuration x&#39;.</p><p>Abstract type representing a move operation in the context of Green Function Monte Carlo simulations.</p><p>This abstract type serves as a base for defining various move operations that can be performed during the simulation process. Specific move types should inherit from this abstract type and implement the required functionality.</p><p><strong>Interface</strong></p><ul><li><code>apply!(x::AbstractConfig, move::AbstractMove)</code>: Apply the move to the configuration <code>x</code>.</li><li><code>isapplicable(x::AbstractConfig, move::AbstractMove, HilbertSpace::AbstractHilbertSpace)</code>: Check if the move is applicable to the configuration <code>x</code> within the specified <code>HilbertSpace</code>.</li><li><code>affected_sites(move::AbstractMove)</code>: Return the sites affected by the move.</li></ul><p>It is further necessary to implement either of the three methods:</p><ul><li><code>move_dx(move::AbstractMove)</code> Return the values of the move applied to the configuration <code>x</code>. i.e. x′ - x.</li><li><code>move_dx_before(move::AbstractMove,x::AbstractConfig</code>: Uses x to compute the move values before applying the move to the configuration. Defaults to <code>move_dx(move)</code></li><li><code>move_dx_after(move::AbstractMove,x::AbstractConfig)</code>: Uses x to compute the move values after applying the move to the configuration. Defaults to <code>move_dx(move)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L47-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractObservable" href="#GreenFunctionMonteCarlo.AbstractObservable"><code>GreenFunctionMonteCarlo.AbstractObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for observables. An observable must be a function that takes a spin configuration and returns an array. To define a subtype of O of <code>AbstractObservable</code>, one must define the following functions:</p><ul><li><code>obs(::O)</code> returns the buffer array for the output of the observable.</li><li><code>O(out,Conf)</code>: Writes the observable for the given configuration to the preallocated array <code>out</code>. Returns out.</li><li><code>Base.copy(O::O)</code>: Returns a copy of the observable.</li></ul><p>If no preallocated array is given, the observable defaults to using the buffer array <code>obs(O)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractObservable.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractObserver" href="#GreenFunctionMonteCarlo.AbstractObserver"><code>GreenFunctionMonteCarlo.AbstractObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for observables in GFMC which are recorded during the run. Observables should always contain the table recording reconfiguration processes, the energies, and the total weights of each Markov step.</p><p><strong>Interface:</strong></p><ul><li><code>saveObservables_before!(Observables,i,Walkers,propagator)</code>: Saves the observables for the given iteration <code>i</code> and walker ensemble <code>Walkers</code>.</li><li><code>saveObservables_after!(Observables,i,Walkers,propagator)</code>: Saves the observables for the given iteration <code>i</code> and walker ensemble <code>Walkers</code> after reconfiguration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractObserver.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractOperator" href="#GreenFunctionMonteCarlo.AbstractOperator"><code>GreenFunctionMonteCarlo.AbstractOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractOperator</code></pre><p>An abstract type representing a general operator. This serves as a base type for defining various specific operators in the context of the Green Function Monte Carlo project.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractPropagator" href="#GreenFunctionMonteCarlo.AbstractPropagator"><code>GreenFunctionMonteCarlo.AbstractPropagator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPropagator</code></pre><p>An abstract type representing a propagator. Examples include discrete or continuous time methods.</p><p><strong>Interface:</strong></p><ul><li><code>propagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())</code>: Propagate the walkers in the ensemble using the specified moves and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractPropagator.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractReconfigurationScheme" href="#GreenFunctionMonteCarlo.AbstractReconfigurationScheme"><code>GreenFunctionMonteCarlo.AbstractReconfigurationScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReconfigurationScheme</code></pre><p>An abstract type that serves as a base for defining different reconfiguration strategies  in the context of the Green Function Monte Carlo framework. </p><p><strong>Interface</strong></p><ul><li><code>reconfigurateWalkers!(Walkers::AbstractWalkerEnsemble,reconfiguration::AbstractReconfigurationScheme,rng::Random.AbstractRNG)</code></li><li><code>get_reconfigurationList(reconfiguration::AbstractReconfigurationScheme)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractReconfigurationScheme.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractSignFreeOperator" href="#GreenFunctionMonteCarlo.AbstractSignFreeOperator"><code>GreenFunctionMonteCarlo.AbstractSignFreeOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSignFreeOperator &lt;: AbstractOperator</code></pre><p>An abstract type representing a sign-free operator in the context of Green Function Monte Carlo simulations. </p><p><strong>Interface:</strong></p><ul><li><code>get_diagonal(O::AbstractSignFreeOperator)</code>: return the diagonal operator associated with the sign-free operator <code>O</code></li><li><code>get_offdiagonal_elements(O::AbstractSignFreeOperator)</code>: return the weights associated with the off-diagonal operator <code>O</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractWalkerEnsemble" href="#GreenFunctionMonteCarlo.AbstractWalkerEnsemble"><code>GreenFunctionMonteCarlo.AbstractWalkerEnsemble</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractWalkerEnsemble</code></pre><p>An abstract type that represents an ensemble of configurations (i.e. spins, bosons on a lattice for each walker) in the context of the Green Function Monte Carlo project. </p><p><strong>Interface (required)</strong></p><ul><li><code>getConfig(X::AbstractWalkerEnsemble,α)</code>:  get the configuration of the α-th walker in the ensemble.</li><li><code>getMoveWeights(X::AbstractWalkerEnsemble,α)</code>: get the weights of the moves for the α-th walker in the ensemble.</li><li><code>getBuffer(X::AbstractWalkerEnsemble,α)</code>: get the buffer associated with the α-th walker in the ensemble.</li><li><code>getWalkerWeights(X::AbstractWalkerEnsemble)</code>: get the weights of the Walkers in the ensemble.</li></ul><p><strong>Interface (optional)</strong></p><ul><li><code>Base.eachindex(X::AbstractWalkerEnsemble)</code>: iterate over the indices of the ensemble.</li><li><code>getNWalkers(X::AbstractWalkerEnsemble)</code>: get the number of walkers in the ensemble.</li><li><code>getConfigs(X::AbstractWalkerEnsemble)</code>: get all configurations in the ensemble.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractWalkerEnsemble.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.BasicAccumulator" href="#GreenFunctionMonteCarlo.BasicAccumulator"><code>GreenFunctionMonteCarlo.BasicAccumulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BasicAccumulator{T_high&lt;:AbstractFloat} &lt;: AbstractObserver</code></pre><p>A structure that represents a basic accumulator for observing energy and weights during simulations. Instead of storing observables at each step, the expectation values are computed on the fly, reducing the storage requirements significantly. Note that it is advisable to use a good guess of the average weight in the propagator to reduce numerical precision loss.</p><p><strong>Type Parameters</strong></p><ul><li><code>T_high</code>: The floating-point type used for observables,  constrained to subtypes of <code>AbstractFloat</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/BasicAccumulator.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.BasicObserver" href="#GreenFunctionMonteCarlo.BasicObserver"><code>GreenFunctionMonteCarlo.BasicObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BasicObserver{DT&lt;:AbstractFloat} &lt;: AbstractObserver</code></pre><p>Saves the energies, weights and reconfigurations of the walkers during the Monte Carlo simulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Data type for the energies and weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/BasicObserver.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.BosonConfig" href="#GreenFunctionMonteCarlo.BosonConfig"><code>GreenFunctionMonteCarlo.BosonConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BosonConfig{T, N, Arr&lt;:AbstractArray{T, N}} &lt;: AbstractConfig{T, N}</code></pre><p>Represents a configuration of bosonic particles in a given formalism. This structure is parameterized by:</p><ul><li><code>T</code>: The type of the elements in the configuration (e.g., <code>Bool</code> or <code>UInt8</code>).</li><li><code>N</code>: The dimensionality of the configuration space.</li><li><code>Arr&lt;:AbstractArray{T, N}</code>: The type of the array used to store the configuration data, which must be a subtype of <code>AbstractArray</code> with element type <code>T</code> and dimensionality <code>N</code>.</li></ul><p>This type is a subtype of <code>AbstractConfig{T, N}</code>, which provides a common interface for configurations in the system and implements the AbstractArray interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/BosonicConfig.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.BosonHilbertSpace" href="#GreenFunctionMonteCarlo.BosonHilbertSpace"><code>GreenFunctionMonteCarlo.BosonHilbertSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BosonHilbertSpace{Cons&lt;:AbstractConstraint} &lt;: AbstractHilbertSpace</code></pre><p>A structure representing the Hilbert space for bosonic systems.</p><p><strong>Type Parameters</strong></p><ul><li><code>Cons&lt;:AbstractConstraint</code>: A type that defines the constraints applied to the bosonic Hilbert space. This allows for flexible customization of the space&#39;s properties.</li></ul><p><strong>Supertype</strong></p><ul><li><code>AbstractHilbertSpace</code>: This structure is a subtype of <code>AbstractHilbertSpace</code>, indicating that it represents a specific type of quantum mechanical Hilbert space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/BosonicConfig.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.CombinedObserver" href="#GreenFunctionMonteCarlo.CombinedObserver"><code>GreenFunctionMonteCarlo.CombinedObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CombinedObserver{T}</code></pre><p>A struct that represents a combined observer, which is a collection of multiple observers grouped together.  This allows for observing multiple quantities or behaviors simultaneously.</p><p><strong>Fields</strong></p><ul><li><code>Observers::T</code>: A collection containing the individual observers.</li></ul><p><strong>Usage</strong></p><p>This struct is useful for combining multiple observer objects into a single entity, enabling them to be managed and used collectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/CombinedObserver.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ConfigObserver" href="#GreenFunctionMonteCarlo.ConfigObserver"><code>GreenFunctionMonteCarlo.ConfigObserver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConfigObserver(filename, config::AbstractConfig{T,N}, NSteps::Integer, NWalkers::Integer) where {T,N}</code></pre><p>Creates a combined observer that tracks energy, weight, reconfigurations and configurations of the walkers during the Monte Carlo simulation. The observer saves the data to a file with the given filename.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The name of the file where the configuration data will be saved.</li><li><code>config::AbstractConfig{T,N}</code>: The initial configuration object representing the system state.</li><li><code>NSteps::Integer</code>: The number of simulation steps to be observed.</li><li><code>NWalkers::Integer</code>: The number of walkers (or particles) in the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/ConfigObserver.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ConfigurationObserver" href="#GreenFunctionMonteCarlo.ConfigurationObserver"><code>GreenFunctionMonteCarlo.ConfigurationObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ConfigurationObserver{T} &lt;: AbstractObserver</code></pre><p>Saves the configurations of the walkers during the Monte Carlo simulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Data type for the configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/ConfigObserver.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ContinuousTimePropagator" href="#GreenFunctionMonteCarlo.ContinuousTimePropagator"><code>GreenFunctionMonteCarlo.ContinuousTimePropagator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContinuousTimePropagator{T&lt;:AbstractFloat} &lt;: AbstractPropagator</code></pre><p>A structure representing a imaginary time projection of a trial wavefunction, also referred to as the &quot;Continuous time limit&quot;. </p><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:AbstractFloat</code>: The floating-point type used for numerical computations  (e.g., <code>Float64</code>, <code>Float32</code>).</li></ul><p><strong>Supertype</strong></p><ul><li><code>AbstractPropagator</code>: This structure is a subtype of <code>AbstractPropagator</code>,  indicating that it implements the required interface for propagators in the  Green Function Monte Carlo framework.</li></ul><p><strong>Fields</strong></p><ul><li><code>dτ::T</code>: The time step for the propagation, which is a floating-point value. A small value may be inefficient in exploring the Hilbert space, while a large value will lead to a more unstable propagation. A good starting point is <code>dτ = 0.1</code>.</li><li><code>w_avg_estimate::T</code>: An estimate of the average weight to reduce floating point errors. Ideally given by the exact ground state energy of the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ContinuousTimePropagator.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.DiagOperator" href="#GreenFunctionMonteCarlo.DiagOperator"><code>GreenFunctionMonteCarlo.DiagOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagOperator{F} &lt;: DiagonalOperator</code></pre><p>A type that can hold an arbitrary function <code>H_xx = f(x)</code> as a diagonal operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/LocalOperator.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.DiagonalOperator" href="#GreenFunctionMonteCarlo.DiagonalOperator"><code>GreenFunctionMonteCarlo.DiagonalOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalOperator</code></pre><p>An abstract type representing a diagonal operator in the context of Green Function Monte Carlo simulations. A diagonal operator is special in the sense that it will not change the configuration of the system when applied to it and will only return a number.</p><p><strong>Interface:</strong></p><ul><li><code>(D::DiagonalOperator)(x)</code> : return the value of the operator applied to the configuration <code>x</code></li><li><code>(D::DiagonalOperator)(x, params)</code>: return the value of the operator applied to the configuration <code>x</code> with parameters <code>params</code>, which can be used to store buffers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.EqualWeightSuperposition" href="#GreenFunctionMonteCarlo.EqualWeightSuperposition"><code>GreenFunctionMonteCarlo.EqualWeightSuperposition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EqualWeightSuperposition &lt;: AbstractGuidingFunction</code></pre><p>Represents a guiding function that models an equal weight superposition of states, i.e. ψ(x) = 1 for all x, provided that the configuration x is a valid configuration satisfying all constraints. This structure is a subtype of <code>AbstractGuidingFunction</code> and is used in the context of variational calculations within the Green Function Monte Carlo framework.</p><p><strong>See Also</strong></p><ul><li><code>AbstractGuidingFunction</code>: The abstract type that this struct extends.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Variational/EqualWeightSuperposition.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.GFMCProblem" href="#GreenFunctionMonteCarlo.GFMCProblem"><code>GreenFunctionMonteCarlo.GFMCProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GFMCProblem{WE&lt;:AbstractWalkerEnsemble, Prop&lt;:AbstractPropagator, GF&lt;:AbstractGuidingFunction, 
                 SFO&lt;:AbstractSignFreeOperator, HS&lt;:AbstractHilbertSpace, PS&lt;:AbstractParallelizationScheme, 
                 RS&lt;:AbstractReconfigurationScheme} &lt;: AbstractGFMCProblem</code></pre><p>Represents a Green&#39;s Function Monte Carlo (GFMC) problem with the following type parameters:</p><ul><li><code>WE&lt;:AbstractWalkerEnsemble</code>: The type of the walker ensemble used in the simulation.</li><li><code>Prop&lt;:AbstractPropagator</code>: The propagator responsible for evolving the system.</li><li><code>GF&lt;:AbstractGuidingFunction</code>: The guiding function used to improve the efficiency of the simulation.</li><li><code>SFO&lt;:AbstractSignFreeOperator</code>: The operator ensuring sign-free sampling in the simulation, containing only negative elements on the off-diagonal.</li><li><code>HS&lt;:AbstractHilbertSpace</code>: The Hilbert space in which the problem is defined.</li><li><code>PS&lt;:AbstractParallelizationScheme</code>: The parallelization scheme used for distributing computation.</li><li><code>RS&lt;:AbstractReconfigurationScheme</code>: The reconfiguration scheme used to manage walker populations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ManyWalkerGFMC.jl#L107-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.GreenFunctionMonteCarlo" href="#GreenFunctionMonteCarlo.GreenFunctionMonteCarlo"><code>GreenFunctionMonteCarlo.GreenFunctionMonteCarlo</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Overview</strong></p><p><code>GreenFunctionMonteCarlo.jl</code> is a Julia package designed for performing Green Function Monte Carlo (GFMC) simulations on lattice models.</p><p>Presently, this package treats only Hamiltonians that are free of the sign problem, i.e. whose elements satisfy</p><p class="math-container">\[
H_{x, x&#39;} \leq 0 \quad \forall x \neq x&#39;\]</p><p>where <span>$H_{x, x&#39;}$</span> is the matrix element of the Hamiltonian between two configurations (spins or bosons) <span>$x$</span> and <span>$x&#39;$</span>. </p><p><strong>Usage:</strong></p><pre><code class="nohighlight hljs">using GreenFunctionMonteCarlo, LinearAlgebra
NSites = 3
Nwalkers = 10
NSteps = 10
Hilbert = BosonHilbertSpace(NSites, HardCoreConstraint())
moves = eachcol(Bool.(I(NSites))) # each move flips a single spin
offdiagElements = -ones(NSites)
H = localOperator(eachrow(moves), offdiagElements, DiagOperator(x-&gt;0), Hilbert)

problem = GFMCProblem(BosonConfig(Hilbert), Nwalkers, ContinuousTimePropagator(0.1); logψ = EqualWeightSuperposition(), H, Hilbert)
Observer = ConfigObserver(BosonConfig(Hilbert), NSteps, Nwalkers) # Observer to measure the energy and configurations
runGFMC!(problem, NoObserver(), 100) #run for 100 steps without observing to equilibrate
runGFMC!(problem, Observer, NSteps) #run for NSteps steps</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/GreenFunctionMonteCarlo.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.HardCoreConstraint" href="#GreenFunctionMonteCarlo.HardCoreConstraint"><code>GreenFunctionMonteCarlo.HardCoreConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HardCoreConstraint &lt;: AbstractConstraint</code></pre><p>A struct representing a hard-core constraint in the system. This constraint  enforces that certain configurations are not allowed, typically used in  bosonic systems to model hard-core interactions where particles cannot  occupy the same state or position.</p><p>This type is a subtype of <code>AbstractConstraint</code>, which serves as a base  for defining various constraints in the system. Useful for simulating spin-1/2 systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/BosonicConfig.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.InverseMove" href="#GreenFunctionMonteCarlo.InverseMove"><code>GreenFunctionMonteCarlo.InverseMove</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct InverseMove{T&lt;:AbstractMove} &lt;: AbstractMove</code></pre><p>A type representing an inverse move in a Monte Carlo simulation. This type is parameterized by <code>T</code>, which must be a subtype of <code>AbstractMove</code>. The <code>InverseMove</code> struct is used to encapsulate the concept of an inverse operation corresponding to a given move in the simulation.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: A subtype of <code>AbstractMove</code> that specifies the type of move for which this struct represents the inverse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.Jastrow" href="#GreenFunctionMonteCarlo.Jastrow"><code>GreenFunctionMonteCarlo.Jastrow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Jastrow{T&lt;:Real} &lt;: AbstractGuidingFunction</code></pre><p>A structure representing the Jastrow factor in a variational Monte Carlo simulation. This function strikes a good balance between accuracy and computational efficiency in the context of Green Function Monte Carlo. <span>$log(ψ(x)) = \sum_i m_i x_i + \frac{1}{2}\sum_{i,j} v_{ij} x_i x_j$</span></p><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:Real</code>: The numeric type used for the parameters of the Jastrow factor  (e.g., <code>Float64</code>, <code>Float32</code>).</li></ul><p><strong>Usage</strong></p><p>logψ = Jastrow(N,Float64) # Create a Jastrow factor for <code>N</code> sites with parameters of type <code>Float64</code>. logψ = Jastrow(conf,Float64) # Create a Jastrow factor for configurations similar to <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Variational/Jastrow.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NaiveFunction" href="#GreenFunctionMonteCarlo.NaiveFunction"><code>GreenFunctionMonteCarlo.NaiveFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>provides a naive wrapper for a guiding function which does not use any buffer. Useful for debugging and testing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Variational/NaiveFunction.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NoLogger" href="#GreenFunctionMonteCarlo.NoLogger"><code>GreenFunctionMonteCarlo.NoLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoLogger &lt;: AbstractLogger</code></pre><p>A placeholder implementation that does not perform any logging.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Loggers/NoLogger.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NoObserver" href="#GreenFunctionMonteCarlo.NoObserver"><code>GreenFunctionMonteCarlo.NoObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoObserver &lt;: AbstractObserver</code></pre><p>An observer type that does not save anything. Can be used to evolve the system in the most efficient way, i.e. for equilibration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ManyWalkerGFMC.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ObservableAccumulator" href="#GreenFunctionMonteCarlo.ObservableAccumulator"><code>GreenFunctionMonteCarlo.ObservableAccumulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ObservableAccumulator{ObsType&lt;:AbstractObservable, T_high&lt;:AbstractFloat, T_low&lt;:Real}</code></pre><p>An accumulator for observables in Monte Carlo simulations. This struct is designed to collect and process measurements of a given observable type during the simulation, supporting both high-precision (<code>T_high</code>) and lower-precision (<code>T_low</code>) data types.</p><p><strong>Type Parameters</strong></p><ul><li><code>ObsType&lt;:AbstractObservable</code>: The type of observable being accumulated.</li><li><code>T_high&lt;:AbstractFloat</code>: The floating-point type used for high-precision accumulation (e.g., <code>Float64</code>).</li><li><code>T_low&lt;:Real</code>: The type used for lower-precision to speed-up calculations (typically <code>Float32</code>).</li></ul><p><strong>Description</strong></p><p><code>ObservableAccumulator</code> is typically used as part of the observer pattern in Monte Carlo simulations, where it collects measurements of observables at each step and provides methods for statistical analysis, such as computing averages and variances.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/ObservableAccumulator.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.OneBodyDiagOperator" href="#GreenFunctionMonteCarlo.OneBodyDiagOperator"><code>GreenFunctionMonteCarlo.OneBodyDiagOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneBodyDiagOperator{T&lt;:AbstractVector} &lt;: DiagonalOperator</code></pre><p>A type that represents arbitrary diagonal one-body interactions <code>H_xx = sum_{i} m_i x_i</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/LocalOperator.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ProblemEnsemble" href="#GreenFunctionMonteCarlo.ProblemEnsemble"><code>GreenFunctionMonteCarlo.ProblemEnsemble</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProblemEnsemble{P&lt;:AbstractGFMCProblem} &lt;: AbstractGFMCProblem</code></pre><p>Run multiple GFMC problems in parallel. Useful to estimate errors.</p><p><strong>Usage example:</strong></p><pre><code class="nohighlight hljs">P = ProblemEnsemble([GFMCProblem1, GFMCProblem2, ...])

problems = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for _ in 1:10])

Observers = [ConfigObserver(&quot;output_$i.h5&quot;,startConfig, NSteps, NWalkers) for i in 1:10] #note that each observer must have its own file

runGFMC!(problems, NoObserver(),100) #equilibrate
runGFMC!(problems, Observers)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ManyWalkerGFMC.jl#L233-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ProgressBarLogger" href="#GreenFunctionMonteCarlo.ProgressBarLogger"><code>GreenFunctionMonteCarlo.ProgressBarLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProgressBarLogger(; kwargs...)</code></pre><p>Creates a progress bar logger with customizable update intervals and additional options.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs...</code>: Additional keyword arguments to customize the behavior of the progress bar logger. See <code>GreenFunctionMonteCarlo.ProgressMeter.Progress</code> for more details.</li></ul><p><strong>Returns</strong></p><p>A progress bar logger instance that can be used to track and display progress in a task.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Loggers/ProgressBarLogger.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.SimpleLogger" href="#GreenFunctionMonteCarlo.SimpleLogger"><code>GreenFunctionMonteCarlo.SimpleLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SimpleLogger &lt;: AbstractLogger</code></pre><p>A simple logger implementation that inherits from <code>AbstractLogger</code>.</p><p><strong>Fields</strong></p><ul><li><code>n_report::Int</code>: The number of steps in the log report.</li></ul><p>This logger can be used to control and manage logging behavior in a straightforward manner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Loggers/SimpleLogger.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.TwoBodyDiagOperator" href="#GreenFunctionMonteCarlo.TwoBodyDiagOperator"><code>GreenFunctionMonteCarlo.TwoBodyDiagOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoBodyDiagOperator{T&lt;:AbstractMatrix} &lt;: DiagonalOperator</code></pre><p>A type that represents arbitrary diagonal two-body interactions <code>H_xx = sum_{i,j} v_ij x_i x_j</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/LocalOperator.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ZeroDiagOperator" href="#GreenFunctionMonteCarlo.ZeroDiagOperator"><code>GreenFunctionMonteCarlo.ZeroDiagOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroDiagOperator &lt;: DiagonalOperator</code></pre><p>A struct representing a diagonal operator <code>H_xx = 0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/LocalOperator.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.allocate_GWF_buffers" href="#GreenFunctionMonteCarlo.allocate_GWF_buffers"><code>GreenFunctionMonteCarlo.allocate_GWF_buffers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer, x)</code></pre><p>Allocates a specified number of guiding wave function (GWF) buffers.</p><p><strong>Arguments</strong></p><ul><li><code>logψ::AbstractGuidingFunction</code>: The guiding function for which the buffers are being allocated.</li><li><code>NBuffers::Integer</code>: The number of buffers to allocate.</li><li><code>x</code>: An exemplary configuration</li></ul><p><strong>Returns</strong></p><ul><li>An array filled with <code>NBuffers</code> instances of <code>AbstractGuidingFunctionBuffer</code>. Defaults to an array of <code>NotImplementedBuffer</code> instances.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractGuidingFunctions.jl#L52-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.apply!" href="#GreenFunctionMonteCarlo.apply!"><code>GreenFunctionMonteCarlo.apply!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply!(x::AbstractConfig, move::AbstractMove)</code></pre><p>Throws a <code>MethodError</code> indicating that the <code>apply!</code> function has not been implemented for the given <code>AbstractConfig</code> type and <code>move</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: An instance of a type that is a subtype of <code>AbstractConfig</code>.</li><li><code>move::AbstractMove</code>: A move or operation to be applied to the configuration <code>x</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>MethodError</code>: Always thrown to indicate that the method needs to be implemented for specific subtypes of <code>AbstractConfig</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L83-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.continuos_time_propagation!" href="#GreenFunctionMonteCarlo.continuos_time_propagation!"><code>GreenFunctionMonteCarlo.continuos_time_propagation!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuos_time_propagation!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, dτ::Real, parallelization::MultiThreaded, RNG::Random.AbstractRNG = Random.default_rng())</code></pre><p>Perform continuous time propagation on a walker ensemble for a fixed time step <code>dτ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>WE::AbstractWalkerEnsemble</code>: The ensemble of walkers to be propagated.</li><li><code>H::AbstractSignFreeOperator</code>: The Hamiltonian operator used for propagation.</li><li><code>logψ::AbstractGuidingFunction</code>: The guiding function for the propagation.</li><li><code>Hilbert::AbstractHilbertSpace</code>: The Hilbert space in which the propagation occurs.</li><li><code>dτ::Real</code>: The time step for the propagation.</li><li><code>w_avg_estimate::Real</code>: An estimate of the average weight.</li><li><code>parallelization::MultiThreaded</code>: Parallelization settings for the propagation.</li><li><code>RNG::Random.AbstractRNG</code>: The random number generator to be used (default is <code>Random.default_rng()</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ContinuousTimePropagator.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.estimate_weights_continuousTime!" href="#GreenFunctionMonteCarlo.estimate_weights_continuousTime!"><code>GreenFunctionMonteCarlo.estimate_weights_continuousTime!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_weights_continuousTime!(prob; Nepochs=5, Nsamples=100, mProj=50)</code></pre><p>Estimate weights in a continuous-time Monte Carlo simulation. Useful for reducing the floating point errors for accumulators. The results may be passed to  <code>ContinuousTimePropagator(tau,w_avg_estimate)</code> and <code>BasicAccumulator(args...;weight_normalization)</code></p><p><strong>Arguments</strong></p><ul><li><code>prob</code>: The problem instance or data structure containing the simulation setup.</li><li><code>Nepochs</code>: (Optional) Number of epochs to run the estimation. Default is 5.</li><li><code>Nsamples</code>: (Optional) Number of samples per epoch. Default is 100.</li><li><code>mProj</code>: (Optional) Number of projection steps or iterations. Default is 50.</li></ul><p><strong>Description</strong></p><p>This function performs an in-place estimation of weights for a given problem using a continuous-time Monte Carlo approach. The process iterates over a specified number of epochs, drawing samples and projecting as configured by the keyword arguments.</p><p><strong>Returns</strong></p><ul><li>Modifies <code>prob</code> in place which helps to equilibrate</li><li>Returns a rough estimate of the mean total weight and CT.w<em>avg</em>estimate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Observers/estimate_weights.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.fulfills_constraint" href="#GreenFunctionMonteCarlo.fulfills_constraint"><code>GreenFunctionMonteCarlo.fulfills_constraint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fulfills_constraint(x::AbstractArray, HilbertSpace::AbstractHilbertSpace)</code></pre><p>Check if the given configuration <code>x</code> satisfies the constraint of the specified <code>HilbertSpace</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The configuration to be checked.</li><li><code>HilbertSpace::AbstractHilbertSpace</code>: The Hilbert space whose constraint need to be satisfied.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the configuration satisfies the constraint, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractConstraint.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.getEnergies" href="#GreenFunctionMonteCarlo.getEnergies"><code>GreenFunctionMonteCarlo.getEnergies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getEnergies(weights, localEnergies, PMax; kwargs...)</code></pre><p>Compute the energies based on the provided weights and local energies, for the projection steps <code>p = 0,1,2,...,PMax</code>.</p><p><strong>Arguments</strong></p><ul><li><code>weights</code>: A collection of weights associated with the samples.</li><li><code>localEnergies</code>: A collection of local energy values corresponding to the samples.</li><li><code>PMax</code>: An integer indicating the maximum projection order.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>Gnp</code>: optionally provided precomputed normalized accumulated weights.</li></ul><p><strong>Returns</strong></p><p>Returns the computed energies based on the input parameters.</p><p><strong>Notes</strong></p><p>Ensure that the dimensions of <code>weights</code> and <code>localEnergies</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/Evaluation.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.get_move" href="#GreenFunctionMonteCarlo.get_move"><code>GreenFunctionMonteCarlo.get_move</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_move(O::AbstractOperator,idx::Integer)</code></pre><p>Return the move associated with the operator <code>O</code> at index <code>idx</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.get_offdiagonal_elements" href="#GreenFunctionMonteCarlo.get_offdiagonal_elements"><code>GreenFunctionMonteCarlo.get_offdiagonal_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_offdiagonal_elements(O::AbstractSignFreeOperator)</code></pre><p>Return the weights associated with an <code>AbstractSignFreeOperator</code> object <code>O</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.isapplicable" href="#GreenFunctionMonteCarlo.isapplicable"><code>GreenFunctionMonteCarlo.isapplicable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapplicable(x::AbstractConfig, move::AbstractArray, HilbertSpace::AbstractHilbertSpace)</code></pre><p>Check if a given move is applicable to the current configuration within a specified Hilbert space.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: The current configuration.</li><li><code>move::AbstractMove</code>: The proposed move to be applied.</li><li><code>HilbertSpace::AbstractHilbertSpace</code>: The Hilbert space in which the configuration and move are defined.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the move is applicable, <code>false</code> otherwise.</li></ul><p>Defaults to applying the move to the configuration, checking if the constraints are satisfied, and then reverting the move.</p><p>Make sure to implement this function for specific subtypes of <code>AbstractConfig</code> and <code>AbstractHilbertSpace</code> to ensure optimal performance. See also <code>isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L98-L115">source</a></section><section><div><pre><code class="language-julia hljs">isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint) -&gt; Bool</code></pre><p>Check if a given move is applicable to a configuration under a specified constraint.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: The configuration to which the move will be applied.</li><li><code>move::AbstractMove</code>: The move that is being checked for applicability.</li><li><code>constraint::AbstractConstraint</code>: The constraint that must be satisfied for the move to be applicable.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the move is applicable to the configuration under the given constraint, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractOperator.jl#L121-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.minimizeReconfiguration!" href="#GreenFunctionMonteCarlo.minimizeReconfiguration!"><code>GreenFunctionMonteCarlo.minimizeReconfiguration!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimizeReconfiguration!(list)</code></pre><p>given a list of reconfiguration indices, minimizes the number of reconfigurations by swapping elements in the list. Each walker that survives a reconfiguration step remains unchanged while walkers that are killed get assigned to a new index.</p><p><strong>Arguments</strong></p><ul><li><code>list</code>: A collection (e.g., an array) that will be reconfigured in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Reconfiguration/MinimalReconfiguration.jl#L45-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.pre_move_affect!" href="#GreenFunctionMonteCarlo.pre_move_affect!"><code>GreenFunctionMonteCarlo.pre_move_affect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Updates the guiding function buffer before any move is applied.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractGuidingFunctions.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.propagateWalkers!" href="#GreenFunctionMonteCarlo.propagateWalkers!"><code>GreenFunctionMonteCarlo.propagateWalkers!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Propagates walker ensemble <code>X</code> using a collection of moves according to the rules specified by the propagator <code>P</code>. </p><p><strong>Usage:</strong></p><p><code>propagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/AbstractTypes/AbstractPropagator.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.reconfigurateWalkers!" href="#GreenFunctionMonteCarlo.reconfigurateWalkers!"><code>GreenFunctionMonteCarlo.reconfigurateWalkers!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Performs an efficient reconfiguration of walkers. This reconfiguration will not remove walkers if they all have the same weight, which increases the efficiency as more walkers can contribute to the average.</p><p>Matteo Calandra Buonaura and Sandro Sorella Phys. Rev. B 57, 11446 (1998)</p><p><strong>Arguments</strong></p><ul><li><code>Walkers::AbstractWalkerEnsemble</code>: The ensemble of walkers to be reconfigured.</li><li><code>reconfigurationList</code>: A list of indices that will be reconfigured.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/Reconfiguration/MinimalReconfiguration.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.runGFMC!" href="#GreenFunctionMonteCarlo.runGFMC!"><code>GreenFunctionMonteCarlo.runGFMC!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runGFMC!(Walkers::AbstractWalkerEnsemble, Observables::AbstractObserver, reconfiguration::AbstractReconfigurationScheme, 
         range, propagator::AbstractPropagator, logψ::AbstractGuidingFunction, H::AbstractSignFreeOperator, 
         Hilbert::AbstractHilbertSpace, parallelizer::AbstractParallelizationScheme, logger::AbstractLogger, RNG::Random.AbstractRNG)</code></pre><p>Runs the Green Function Monte Carlo (GFMC) simulation for a given system.</p><p><strong>Arguments</strong></p><ul><li><code>Walkers::AbstractWalkerEnsemble</code>: The ensemble of walkers representing the quantum state.</li><li><code>Observables::AbstractObserver</code>: The observer object used to measure physical quantities during the simulation.</li><li><code>reconfiguration::AbstractReconfigurationScheme</code>: The scheme used to reconfigure the walker ensemble to maintain population control.</li><li><code>range</code>: The range of iterations or time steps for the simulation.</li><li><code>propagator::AbstractPropagator</code>: The propagator used to evolve the walkers.</li><li><code>logψ::AbstractGuidingFunction</code>: The guiding function (logarithmic form) used for importance sampling.</li><li><code>H::AbstractSignFreeOperator</code>: The Hamiltonian operator of the system, assumed to be sign-free.</li><li><code>Hilbert::AbstractHilbertSpace</code>: The Hilbert space on which the system is defined.</li><li><code>parallelizer::AbstractParallelizationScheme</code>: The parallelization scheme used to distribute computation across resources.</li><li><code>logger::AbstractLogger</code>: The logger object used to record simulation progress.</li><li><code>RNG::Random.AbstractRNG</code>: The random number generator used for stochastic processes in the simulation.</li></ul><p><strong>Description</strong></p><p>This function performs the GFMC simulation by evolving the walker ensemble using the provided propagator and guiding function. It measures observables diagonal in the computational Basis at each step and applies reconfiguration to control the walker population. The simulation is parallelized according to the specified parallelization scheme.</p><p><strong>Notes</strong></p><ul><li>The function modifies the <code>Walkers</code> object in place.</li><li>Ensure that all input objects are properly initialized before calling this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ManyWalkerGFMC.jl#L67-L93">source</a></section><section><div><pre><code class="language-julia hljs">runGFMC!(prob::GFMCProblem, Observables::AbstractObserver, range; 
         logger = default_logger(), rng = Random.default_rng(), 
         reconfiguration = prob.reconfiguration, Propagator = prob.Propagator, 
         logψ = prob.logψ, H = prob.H, Hilbert = prob.Hilbert, 
         parallelization = prob.parallelization)</code></pre><p>Run the Green&#39;s Function Monte Carlo (GFMC) simulation for the given problem.</p><p><strong>Arguments</strong></p><ul><li><code>prob::GFMCProblem</code>: The GFMC problem instance containing the system configuration and parameters.</li><li><code>Observables::AbstractObserver</code>: An observer object to track and record observables during the simulation.</li><li><code>range</code>: Integer or range: The range of iterations or steps over which the simulation will be performed.</li></ul><p><strong>Keyword Arguments to override default values</strong></p><ul><li><code>logger</code>: (Optional) A logger instance for logging simulation progress. Defaults to <code>default_logger()</code>. Use <code>NoLogger()</code> or <code>nothing</code> to disable logging.</li><li><code>rng</code>: (Optional) A random number generator to ensure reproducibility. Defaults to <code>Random.default_rng()</code>.</li><li><code>reconfiguration</code>: (Optional) The reconfiguration method to be used during the simulation. Defaults to <code>prob.reconfiguration</code>.</li><li><code>Propagator</code>: (Optional) The propagator function for the simulation. Defaults to <code>prob.Propagator</code>.</li><li><code>logψ</code>: (Optional) The logarithm of the wavefunction. Defaults to <code>prob.logψ</code>.</li><li><code>H</code>: (Optional) The Hamiltonian operator. Defaults to <code>prob.H</code>.</li><li><code>Hilbert</code>: (Optional) The Hilbert space of the system. Defaults to <code>prob.Hilbert</code>.</li><li><code>parallelization</code>: (Optional) The parallelization strategy for the simulation. Defaults to <code>prob.parallelization</code>.</li></ul><p><strong>Returns</strong></p><p>This function modifies the <code>prob</code> and <code>Observables</code> in place to reflect the results of the simulation.</p><p><strong>Notes</strong></p><ul><li>Ensure that the <code>prob</code> and <code>Observables</code> are properly initialized before calling this function.</li><li>If <code>range</code> is provided as an integer, it will be converted to a range <code>1:range</code>.</li><li>If <code>logger</code> is <code>nothing</code>, it will default to <code>NoLogger()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/0e2c026bfd574548d132f724f03732c7d4551c91/src/DefaultFormalism/ManyWalkerGFMC.jl#L182-L213">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Example_transverseFieldIsing/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 8 June 2025 14:59">Sunday 8 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
