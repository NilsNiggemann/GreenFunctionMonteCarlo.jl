<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GreenFunctionMonteCarlo.jl</title><meta name="title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta property="og:title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta property="twitter:title" content="Reference · GreenFunctionMonteCarlo.jl"/><meta name="description" content="Documentation for GreenFunctionMonteCarlo.jl."/><meta property="og:description" content="Documentation for GreenFunctionMonteCarlo.jl."/><meta property="twitter:description" content="Documentation for GreenFunctionMonteCarlo.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GreenFunctionMonteCarlo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GreenFunctionMonteCarlo</a></li><li><a class="tocitem" href="../Example_transverseFieldIsing/">Example: Transverse Field Ising Model</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/master/docs/src/Reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractConfig" href="#GreenFunctionMonteCarlo.AbstractConfig"><code>GreenFunctionMonteCarlo.AbstractConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConfig{T,N}</code></pre><p>An abstract type that represents a configuration (i.e. spins, bosons on a lattice).  This type is a subtype of <code>AbstractArray{T,N}</code>.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: The type of the elements in the configuration.</li><li><code>N</code>: The number of dimensions of the configuration.</li></ul><p><strong>Interface</strong></p><ul><li><code>Base.parent(x::AbstractConfig)</code>: return the parent array</li><li>Base.copy(x::AbstractConfig): create a full copy of the configuration</li><li>apply!(x::AbstractConfig, move::Any): apply a move to the configuration</li><li>fulfills_constraints(x::AbstractConfig, HilbertSpace::AbstractHilbertSpace): check if the configuration satisfies the constraints of the Hilbert space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractConfig.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractConstraint" href="#GreenFunctionMonteCarlo.AbstractConstraint"><code>GreenFunctionMonteCarlo.AbstractConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractConstraint</code></pre><p>An abstract type representing a constraint in the context of a Hilbert space.</p><p><strong>Interface</strong></p><ul><li><code>(c)(x::AbstractArray)</code>: Check if the configuration <code>x</code> satisfies the constraint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractConstraint.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractDiagObservable" href="#GreenFunctionMonteCarlo.AbstractDiagObservable"><code>GreenFunctionMonteCarlo.AbstractDiagObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for observables which are diagonal in the computational basis and may be measured for free in GFMC. An observable must be a function that takes a configuration and returns an array.</p><p><strong>Interface:</strong></p><ul><li>obs(::O) returns the buffer array for the output of the observable.</li><li><code>O(out,Conf)</code>: Writes the observable for the given configuration to the preallocated array <code>out</code>. Returns out.</li><li>Base.copy(O::O): Returns a copy of the observable.</li></ul><p>If no preallocated array is given, the observable defaults to using the buffer array <code>obs(O)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractObserver.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGFMCProblem" href="#GreenFunctionMonteCarlo.AbstractGFMCProblem"><code>GreenFunctionMonteCarlo.AbstractGFMCProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Abstract type for GFMC problems.</code></pre><p><strong>Interface:</strong></p><ul><li><code>runGFMC!(problem::AbstractGFMCProblem,args...;kwargs...)</code>: Run the GFMC algorithm for the given problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractGFMCProblem.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGuidingFunction" href="#GreenFunctionMonteCarlo.AbstractGuidingFunction"><code>GreenFunctionMonteCarlo.AbstractGuidingFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGuidingFunction</code></pre><p>An abstract type for all guiding function implementations in Green Function Monte Carlo. Subtypes of this correspond to implementations of concrete guiding functions, particularly variational wavefunctions. For optimal performance, it is recommended to implement the function log<em>psi</em>diff! for the specific guiding function type.</p><p><strong>Interface</strong></p><ul><li><code>logψ(x::AbstractArray)</code>: return the logarithm of the guiding function evaluated at the configuration <code>x</code>.</li><li><code>logψ(x::AbstractArray, H::AbstractHilbertSpace)</code>: return the logarithm of the guiding function evaluated at the configuration <code>x</code> in the specified <code>HilbertSpace</code>.</li><li><code>log_psi_diff(x::AbstractArray, dx::AbstractArray, logψ::AbstractGuidingFunction, Buffer::AbstractGuidingFunctionBuffer, Hilbert::AbstractHilbertSpace)</code>: return the logarithm of the ratio of the guiding function evaluated at the configuration <code>x</code> and <code>x+dx</code> in the specified <code>HilbertSpace</code>. Returns <code>-Inf</code> if the move is not applicable.</li><li>get_params(logψ::AbstractGuidingFunction): return the parameters of the guiding function as a linear Array. It is recommended to use RecursiveArrayTools.jl for this purpose.</li><li>HDF5.h5write(file::AbstractString, name::AbstractString, logψ::AbstractGuidingFunction): write the guiding function to an HDF5 file.</li></ul><p><strong>Interface (optional)</strong></p><ul><li>allocate<em>GWF</em>buffers(logψ::AbstractGuidingFunction, NBuffers::Integer): allocate NBuffers instances of a buffer for the guiding function. Defaults to an array of EmptyGWFBuffer instances.</li><li>compute<em>GWF</em>buffer!(Buffer::AbstractGuidingFunctionBuffer, logψ::AbstractGuidingFunction, x): compute the full buffer for the guiding function at the configuration <code>x</code>. </li><li>pre<em>move</em>affect!(Buffer::AbstractGuidingFunctionBuffer, x, moves, logψ::AbstractGuidingFunction): perform any necessary operations before computing ratios ψx´_ψx.</li><li>post<em>move</em>affect!(Buffer::AbstractGuidingFunctionBuffer, x, dx, logψ::AbstractGuidingFunction): perform any necessary operations after the move is applied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractGuidingFunctions.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer" href="#GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer"><code>GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGuidingFunctionBuffer</code></pre><p>An abstract type that serves as a base for defining guiding function buffer structures. </p><p><strong>Interface</strong></p><ul><li><code>setBuffer!(BA::AbstractGuidingFunctionBuffer, BB::AbstractGuidingFunctionBuffer)</code>: set the buffer <code>BA</code> to the values of the buffer <code>BB</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractGuidingFunctions.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractHilbertSpace" href="#GreenFunctionMonteCarlo.AbstractHilbertSpace"><code>GreenFunctionMonteCarlo.AbstractHilbertSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractHilbertSpace</code></pre><p>An abstract type representing a Hilbert space. This type serves as a base for defining various specific Hilbert spaces used in the project. Generally, a hilbert space should be defined by the number of sites, the number of local degrees of freedom (i.e. spin), and the constraint that the configurations must satisfy. </p><p><strong>Interface</strong></p><ul><li><code>constraint(HilbertSpace::AbstractHilbertSpace)</code>: Return the constraint that the configurations in the Hilbert space must satisfy.</li><li><code>Base.size(HilbertSpace::AbstractHilbertSpace)</code>: Return the size of a config in the Hilbert space.</li></ul><p><strong>Interface (optional)</strong></p><ul><li>fulfills_constraint(x,HilbertSpace::AbstractHilbertSpace): Check if the given configuration <code>x</code> satisfies the constraint of the specified <code>HilbertSpace</code>. Defaults to <code>constraint(HilbertSpace)(x)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractHilbertSpace.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractMove" href="#GreenFunctionMonteCarlo.AbstractMove"><code>GreenFunctionMonteCarlo.AbstractMove</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMove</code></pre><p>Abstract type representing a move, i.e. an operation that changes a configuration x to a new configuration x&#39;.</p><p>Abstract type representing a move operation in the context of Green Function Monte Carlo simulations.</p><p>This abstract type serves as a base for defining various move operations that can be performed during the simulation process. Specific move types should inherit from this abstract type and implement the required functionality.</p><p><strong>Interface</strong></p><ul><li><code>apply!(x::AbstractConfig, move::AbstractMove)</code>: Apply the move to the configuration <code>x</code>.</li><li><code>isapplicable(x::AbstractConfig, move::AbstractMove, HilbertSpace::AbstractHilbertSpace)</code>: Check if the move is applicable to the configuration <code>x</code> within the specified <code>HilbertSpace</code>.</li><li>affected_sites(move::AbstractMove): Return the sites affected by the move.</li><li>move_dx(move::AbstractMove,x::AbstractConfig): Return the values of the move applied to the configuration <code>x</code>. i.e. the change in x when the move is applied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractObserver" href="#GreenFunctionMonteCarlo.AbstractObserver"><code>GreenFunctionMonteCarlo.AbstractObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for observables in GFMC which are recorded during the run. Observables should always contain the table recording reconfiguration processes, the energies, and the total weights of each Markov step.</p><p><strong>Interface:</strong></p><ul><li>saveObservables_before!(Observables,i,Walkers,propagator): Saves the observables for the given iteration <code>i</code> and walker ensemble <code>Walkers</code>.</li><li>saveObservables_after!(Observables,i,Walkers,propagator): Saves the observables for the given iteration <code>i</code> and walker ensemble <code>Walkers</code> after reconfiguration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractObserver.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractOperator" href="#GreenFunctionMonteCarlo.AbstractOperator"><code>GreenFunctionMonteCarlo.AbstractOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractOperator</code></pre><p>An abstract type representing a general operator. This serves as a base type for defining various specific operators in the context of the Green Function Monte Carlo project.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractPropagator" href="#GreenFunctionMonteCarlo.AbstractPropagator"><code>GreenFunctionMonteCarlo.AbstractPropagator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPropagator</code></pre><p>An abstract type representing a propagator. Examples include discrete or continuous time methods.</p><p><strong>Interface:</strong></p><ul><li><code>propagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())</code>: Propagate the walkers in the ensemble using the specified moves and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractPropagator.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractReconfigurationScheme" href="#GreenFunctionMonteCarlo.AbstractReconfigurationScheme"><code>GreenFunctionMonteCarlo.AbstractReconfigurationScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReconfigurationScheme</code></pre><p>An abstract type that serves as a base for defining different reconfiguration strategies  in the context of the Green Function Monte Carlo framework. </p><p><strong>Interface</strong></p><ul><li><code>reconfigurateWalkers!(Walkers::AbstractWalkerEnsemble,reconfiguration::AbstractReconfigurationScheme,rng::Random.AbstractRNG)</code></li><li>get_reconfigurationList(reconfiguration::AbstractReconfigurationScheme)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractReconfigurationScheme.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractSignFreeOperator" href="#GreenFunctionMonteCarlo.AbstractSignFreeOperator"><code>GreenFunctionMonteCarlo.AbstractSignFreeOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSignFreeOperator &lt;: AbstractOperator</code></pre><p>An abstract type representing a sign-free operator in the context of Green Function Monte Carlo simulations. </p><p><strong>Interface:</strong></p><ul><li>get_diagonal(O::AbstractSignFreeOperator): return the diagonal operator associated with the sign-free operator <code>O</code></li><li>get<em>offdiagonal</em>elements(O::AbstractSignFreeOperator): return the weights associated with the off-diagonal operator <code>O</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.AbstractWalkerEnsemble" href="#GreenFunctionMonteCarlo.AbstractWalkerEnsemble"><code>GreenFunctionMonteCarlo.AbstractWalkerEnsemble</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractWalkerEnsemble</code></pre><p>An abstract type that represents an ensemble of configurations (i.e. spins, bosons on a lattice for each walker) in the context of the Green Function Monte Carlo project. </p><p><strong>Interface (required)</strong></p><ul><li>getConfig(X::AbstractWalkerEnsemble,α):  get the configuration of the α-th walker in the ensemble.</li><li>getMoveWeights(X::AbstractWalkerEnsemble,α): get the weights of the moves for the α-th walker in the ensemble.</li><li>getBuffer(X::AbstractWalkerEnsemble,α): get the buffer associated with the α-th walker in the ensemble.</li><li>getWalkerWeights(X::AbstractWalkerEnsemble): get the weights of the Walkers in the ensemble.</li></ul><p><strong>Interface (optional)</strong></p><ul><li>Base.eachindex(X::AbstractWalkerEnsemble): iterate over the indices of the ensemble.</li><li>getNWalkers(X::AbstractWalkerEnsemble): get the number of walkers in the ensemble.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractWalkerEnsemble.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.BasicObserver" href="#GreenFunctionMonteCarlo.BasicObserver"><code>GreenFunctionMonteCarlo.BasicObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BasicObserver{DT&lt;:AbstractFloat} &lt;: AbstractObserver</code></pre><p>Saves the energies, weights and reconfigurations of the walkers during the Monte Carlo simulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Data type for the energies and weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Observers/BasicObserver.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.CombinedObserver" href="#GreenFunctionMonteCarlo.CombinedObserver"><code>GreenFunctionMonteCarlo.CombinedObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CombinedObserver{T}</code></pre><p>A struct that represents a combined observer, which is a collection of multiple observers grouped together.  This allows for observing multiple quantities or behaviors simultaneously.</p><p><strong>Fields</strong></p><ul><li><code>Observers::T</code>: A collection containing the individual observers.</li></ul><p><strong>Usage</strong></p><p>This struct is useful for combining multiple observer objects into a single entity, enabling them to be managed and used collectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Observers/CombinedObserver.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ConfigObserver" href="#GreenFunctionMonteCarlo.ConfigObserver"><code>GreenFunctionMonteCarlo.ConfigObserver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConfigObserver(filename, config::AbstractConfig{T,N}, NSteps::Integer, NWalkers::Integer) where {T,N}</code></pre><p>Creates a combined observer that tracks energy, weight, reconfigurations and configurations of the walkers during the Monte Carlo simulation. The observer saves the data to a file with the given filename.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The name of the file where the configuration data will be saved.</li><li><code>config::AbstractConfig{T,N}</code>: The initial configuration object representing the system state.</li><li><code>NSteps::Integer</code>: The number of simulation steps to be observed.</li><li><code>NWalkers::Integer</code>: The number of walkers (or particles) in the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Observers/ConfigObserver.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ConfigurationObserver" href="#GreenFunctionMonteCarlo.ConfigurationObserver"><code>GreenFunctionMonteCarlo.ConfigurationObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ConfigurationObserver{T} &lt;: AbstractObserver</code></pre><p>Saves the configurations of the walkers during the Monte Carlo simulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: Data type for the configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Observers/ConfigObserver.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.DiagonalOperator" href="#GreenFunctionMonteCarlo.DiagonalOperator"><code>GreenFunctionMonteCarlo.DiagonalOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalOperator</code></pre><p>An abstract type representing a diagonal operator in the context of Green Function Monte Carlo simulations. A diagonal operator is special in the sense that it will not change the configuration of the system when applied to it and will only return a number.</p><p><strong>Interface:</strong></p><ul><li>(D::DiagonalOperator)(x) : return the value of the operator applied to the configuration <code>x</code></li><li>(D::DiagonalOperator)(x, params): return the value of the operator applied to the configuration <code>x</code> with parameters <code>params</code>, which can be used to store buffers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.EqualWeightSuperposition" href="#GreenFunctionMonteCarlo.EqualWeightSuperposition"><code>GreenFunctionMonteCarlo.EqualWeightSuperposition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EqualWeightSuperposition &lt;: AbstractGuidingFunction</code></pre><p>Represents a guiding function that models an equal weight superposition of states, i.e. ψ(x) = 1 for all x, provided that the configuration x is a valid configuration satisfying all constraints. This structure is a subtype of <code>AbstractGuidingFunction</code> and is used in the context of variational calculations within the Green Function Monte Carlo framework.</p><p><strong>See Also</strong></p><ul><li><code>AbstractGuidingFunction</code>: The abstract type that this struct extends.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Variational/EqualWeightSuperposition.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.GFMCProblem" href="#GreenFunctionMonteCarlo.GFMCProblem"><code>GreenFunctionMonteCarlo.GFMCProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GFMCProblem{WE&lt;:AbstractWalkerEnsemble, Prop&lt;:AbstractPropagator, GF&lt;:AbstractGuidingFunction, 
                 SFO&lt;:AbstractSignFreeOperator, HS&lt;:AbstractHilbertSpace, PS&lt;:AbstractParallelizationScheme, 
                 RS&lt;:AbstractReconfigurationScheme} &lt;: AbstractGFMCProblem</code></pre><p>Represents a Green&#39;s Function Monte Carlo (GFMC) problem with the following type parameters:</p><ul><li><code>WE&lt;:AbstractWalkerEnsemble</code>: The type of the walker ensemble used in the simulation.</li><li><code>Prop&lt;:AbstractPropagator</code>: The propagator responsible for evolving the system.</li><li><code>GF&lt;:AbstractGuidingFunction</code>: The guiding function used to improve the efficiency of the simulation.</li><li><code>SFO&lt;:AbstractSignFreeOperator</code>: The operator ensuring sign-free sampling in the simulation, containing only negative elements on the off-diagonal.</li><li><code>HS&lt;:AbstractHilbertSpace</code>: The Hilbert space in which the problem is defined.</li><li><code>PS&lt;:AbstractParallelizationScheme</code>: The parallelization scheme used for distributing computation.</li><li><code>RS&lt;:AbstractReconfigurationScheme</code>: The reconfiguration scheme used to manage walker populations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ManyWalkerGFMC.jl#L100-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.GreenFunctionMonteCarlo" href="#GreenFunctionMonteCarlo.GreenFunctionMonteCarlo"><code>GreenFunctionMonteCarlo.GreenFunctionMonteCarlo</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>GreenFunctionMonteCarlo.jl</strong></p><p><a href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/actions?query=workflow%3ACI"><img src="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/workflows/CI/badge.svg" alt="build"/></a> <a href="https://NilsNiggemann.github.io/GreenFunctionMonteCarlo.jl/dev"><img src="https://img.shields.io/badge/docs-master-blue.svg" alt="Documentation"/></a> &lt;!– Tidyverse lifecycle badges, see https://www.tidyverse.org/lifecycle/ Uncomment or delete as needed. –&gt; <img src="https://img.shields.io/badge/lifecycle-experimental-orange.svg" alt="lifecycle"/>&lt;!– <img src="https://img.shields.io/badge/lifecycle-maturing-blue.svg" alt="lifecycle"/> <img src="https://img.shields.io/badge/lifecycle-stable-green.svg" alt="lifecycle"/> <img src="https://img.shields.io/badge/lifecycle-retired-orange.svg" alt="lifecycle"/> <img src="https://img.shields.io/badge/lifecycle-archived-red.svg" alt="lifecycle"/> <img src="https://img.shields.io/badge/lifecycle-dormant-blue.svg" alt="lifecycle"/> –&gt;</p><p>&lt;!– <a href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl"><img src="https://img.shields.io/github/commits-since/NilsNiggemann/GreenFunctionMonteCarlo.jl/v0.0.1.svg?style=social&amp;logo=github" alt="GitHub commits since tagged version"/></a> –&gt; &lt;!– <a href="https://NilsNiggemann.github.io/GreenFunctionMonteCarlo.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Documentation"/></a> –&gt;</p><p>&lt;!– Aqua badge, see test/runtests.jl –&gt; &lt;!– <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg" alt="Aqua QA"/></a> –&gt;</p><p>&lt;!– travis-ci.com badge, uncomment or delete as needed, depending on whether you are using that service. –&gt; &lt;!– <a href="https://travis-ci.com/NilsNiggemann/GreenFunctionMonteCarlo.jl"><img src="https://travis-ci.com/NilsNiggemann/GreenFunctionMonteCarlo.jl.svg?branch=master" alt="Build Status"/></a> –&gt; &lt;!– NOTE: Codecov.io badge now depends on the token, copy from their site after setting up –&gt; &lt;!– Documentation – uncomment or delete as needed –&gt; &lt;!– START README (DO NOT DELETE THIS LINE!) –&gt;</p><p><strong>Overview</strong></p><p><code>GreenFunctionMonteCarlo.jl</code> is a Julia package designed for performing Green Function Monte Carlo (GFMC) simulations on lattice models.</p><p>Presently, this package treats only Hamiltonians that are free of the sign problem, i.e. whose elements satisfy</p><p class="math-container">\[
H_{x, x&#39;} \leq 0 \quad \forall x \neq x&#39;\]</p><p>where <span>$H_{x, x&#39;}$</span> is the matrix element of the Hamiltonian between two configurations (spins or bosons) <span>$x$</span> and <span>$x&#39;$</span>. </p><p><strong>Features</strong></p><ul><li>[x] Efficient implementation of the fixed-walker formalism for general systems of interacting bosons <a href="#references">[1]</a>.</li><li>[x] Flexible framework for implementation of other algorithms.</li><li>[x] Constraints, such as hardcore boson constraint.</li><li>[x] Interface for the efficient implementation of arbitrary constraints.</li><li>[ ] Measure arbitrary observables in the diagonal basis.</li><li>[ ] Measure offdiagonal observables via <code>straight-forward</code> walking.</li><li>[ ] Allow more direct implementation of spin models.</li><li>[ ] Allow for easy conversions of Hamiltonians and variational wavefunctions from <a href="https://netket.readthedocs.io/en/stable/">Netket</a>.</li></ul><p><strong>Limitations</strong></p><ul><li>The package is currently in the experimental stage and exported functionality may change or break in the future.</li><li>Currently, there is no implementation of the fixed-node approximation <a href="#references">[2]</a> for Hamiltonians with the sign problem.</li></ul><p><strong>Installation</strong></p><p>To install the package, use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(url = &quot;https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl.git&quot;)</code></pre><p><strong>Documentation</strong></p><p>For detailed documentation, including API references and advanced usage, visit the <a href="https://NilsNiggemann.github.io/GreenFunctionMonteCarlo.jl/dev">documentation site</a>. For an example, see <a href="https://nilsniggemann.github.io/GreenFunctionMonteCarlo.jl/dev/Example_transverseFieldIsing/">this section</a>.</p><p><strong>Contributing</strong></p><p>Contributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the <a href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl">GitHub repository</a>.</p><p><strong>License</strong></p><p>This project is licensed under the MIT License. See the <a href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/master/LICENSE">LICENSE</a> file for details.</p><p><strong>References:</strong></p><ul><li>[1] <a href="https://doi.org/10.1103/PhysRevB.57.11446">Buonaura, M. &amp; Sorella, S. Green&#39;s function Monte Carlo method for lattice fermions. Phys. Rev. B 57, 11446 (1998).</a></li><li>[2] <a href="https://doi.org/10.1017/9781316417041">Becca, F. &amp; Sorella, S. <em>Quantum Monte Carlo Approaches for Correlated Systems</em>. Cambridge University Press; 2017.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/GreenFunctionMonteCarlo.jl#L3-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.InverseMove" href="#GreenFunctionMonteCarlo.InverseMove"><code>GreenFunctionMonteCarlo.InverseMove</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct InverseMove{T&lt;:AbstractMove} &lt;: AbstractMove</code></pre><p>A type representing an inverse move in a Monte Carlo simulation. This type is parameterized by <code>T</code>, which must be a subtype of <code>AbstractMove</code>. The <code>InverseMove</code> struct is used to encapsulate the concept of an inverse operation corresponding to a given move in the simulation.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: A subtype of <code>AbstractMove</code> that specifies the type of move for which this struct represents the inverse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.Jastrow" href="#GreenFunctionMonteCarlo.Jastrow"><code>GreenFunctionMonteCarlo.Jastrow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Jastrow{T&lt;:Real} &lt;: AbstractGuidingFunction</code></pre><p>A structure representing the Jastrow factor in a variational Monte Carlo simulation. This function strikes a good balance between accuracy and computational efficiency in the context of Green Function Monte Carlo. <span>$log(ψ(x)) = \sum_i m_i x_i + \frac{1}{2}\sum_{i,j} v_{ij} x_i x_j$</span></p><p><strong>Type Parameters</strong></p><ul><li><code>T&lt;:Real</code>: The numeric type used for the parameters of the Jastrow factor  (e.g., <code>Float64</code>, <code>Float32</code>).</li></ul><p><strong>Usage</strong></p><p>logψ = Jastrow(N,Float64) # Create a Jastrow factor for <code>N</code> sites with parameters of type <code>Float64</code>. logψ = Jastrow(conf,Float64) # Create a Jastrow factor for configurations similar to <code>conf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Variational/Jastrow.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NaiveFunction" href="#GreenFunctionMonteCarlo.NaiveFunction"><code>GreenFunctionMonteCarlo.NaiveFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>provides a naive wrapper for a guiding function which does not use any buffer. Useful for debugging and testing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Variational/NaiveFunction.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NoLogger" href="#GreenFunctionMonteCarlo.NoLogger"><code>GreenFunctionMonteCarlo.NoLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoLogger &lt;: AbstractLogger</code></pre><p>A placeholder implementation that does not perform any logging.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Loggers/NoLogger.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.NoObserver" href="#GreenFunctionMonteCarlo.NoObserver"><code>GreenFunctionMonteCarlo.NoObserver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoObserver &lt;: AbstractObserver</code></pre><p>An observer type that does not save anything. Can be used to evolve the system in the most efficient way, i.e. for equilibration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ManyWalkerGFMC.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ProgressBarLogger" href="#GreenFunctionMonteCarlo.ProgressBarLogger"><code>GreenFunctionMonteCarlo.ProgressBarLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProgressBarLogger(; kwargs...)</code></pre><p>Creates a progress bar logger with customizable update intervals and additional options.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs...</code>: Additional keyword arguments to customize the behavior of the progress bar logger. See <code>GreenFunctionMonteCarlo.ProgressMeter.Progress</code> for more details.</li></ul><p><strong>Returns</strong></p><p>A progress bar logger instance that can be used to track and display progress in a task.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Loggers/ProgressBarLogger.jl#L6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.SimpleLogger" href="#GreenFunctionMonteCarlo.SimpleLogger"><code>GreenFunctionMonteCarlo.SimpleLogger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SimpleLogger &lt;: AbstractLogger</code></pre><p>A simple logger implementation that inherits from <code>AbstractLogger</code>.</p><p><strong>Fields</strong></p><ul><li><code>n_report::Int</code>: The number of steps in the log report.</li></ul><p>This logger can be used to control and manage logging behavior in a straightforward manner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Loggers/SimpleLogger.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.allocate_GWF_buffers" href="#GreenFunctionMonteCarlo.allocate_GWF_buffers"><code>GreenFunctionMonteCarlo.allocate_GWF_buffers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer, x)</code></pre><p>Allocates a specified number of guiding wave function (GWF) buffers.</p><p><strong>Arguments</strong></p><ul><li><code>logψ::AbstractGuidingFunction</code>: The guiding function for which the buffers are being allocated.</li><li><code>NBuffers::Integer</code>: The number of buffers to allocate.</li><li><code>x</code>: An exemplary configuration</li></ul><p><strong>Returns</strong></p><ul><li>An array filled with <code>NBuffers</code> instances of <code>AbstractGuidingFunctionBuffer</code>. Defaults to an array of <code>NotImplementedBuffer</code> instances.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractGuidingFunctions.jl#L52-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.apply!" href="#GreenFunctionMonteCarlo.apply!"><code>GreenFunctionMonteCarlo.apply!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply!(x::AbstractConfig, move::AbstractMove)</code></pre><p>Throws a <code>MethodError</code> indicating that the <code>apply!</code> function has not been implemented for the given <code>AbstractConfig</code> type and <code>move</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: An instance of a type that is a subtype of <code>AbstractConfig</code>.</li><li><code>move::AbstractMove</code>: A move or operation to be applied to the configuration <code>x</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>MethodError</code>: Always thrown to indicate that the method needs to be implemented for specific subtypes of <code>AbstractConfig</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L78-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.continuos_time_propagation!" href="#GreenFunctionMonteCarlo.continuos_time_propagation!"><code>GreenFunctionMonteCarlo.continuos_time_propagation!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuos_time_propagation!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, dτ::Real, parallelization::MultiThreaded, RNG::Random.AbstractRNG = Random.default_rng())</code></pre><p>Perform continuous time propagation on a walker ensemble for a fixed time step <code>dτ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>WE::AbstractWalkerEnsemble</code>: The ensemble of walkers to be propagated.</li><li><code>H::AbstractSignFreeOperator</code>: The Hamiltonian operator used for propagation.</li><li><code>logψ::AbstractGuidingFunction</code>: The guiding function for the propagation.</li><li><code>Hilbert::AbstractHilbertSpace</code>: The Hilbert space in which the propagation occurs.</li><li><code>dτ::Real</code>: The time step for the propagation.</li><li><code>w_avg_estimate::Real</code>: An estimate of the average weight.</li><li><code>parallelization::MultiThreaded</code>: Parallelization settings for the propagation.</li><li><code>RNG::Random.AbstractRNG</code>: The random number generator to be used (default is <code>Random.default_rng()</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ContinuousTimePropagator.jl#L10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.fulfills_constraint" href="#GreenFunctionMonteCarlo.fulfills_constraint"><code>GreenFunctionMonteCarlo.fulfills_constraint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fulfills_constraint(x::AbstractArray, HilbertSpace::AbstractHilbertSpace)</code></pre><p>Check if the given configuration <code>x</code> satisfies the constraint of the specified <code>HilbertSpace</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: The configuration to be checked.</li><li><code>HilbertSpace::AbstractHilbertSpace</code>: The Hilbert space whose constraint need to be satisfied.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the configuration satisfies the constraint, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractConstraint.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.get_move" href="#GreenFunctionMonteCarlo.get_move"><code>GreenFunctionMonteCarlo.get_move</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_move(O::AbstractOperator,idx::Integer)</code></pre><p>Return the move associated with the operator <code>O</code> at index <code>idx</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.get_offdiagonal_elements" href="#GreenFunctionMonteCarlo.get_offdiagonal_elements"><code>GreenFunctionMonteCarlo.get_offdiagonal_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_offdiagonal_elements(O::AbstractSignFreeOperator)</code></pre><p>Return the weights associated with an <code>AbstractSignFreeOperator</code> object <code>O</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.isapplicable" href="#GreenFunctionMonteCarlo.isapplicable"><code>GreenFunctionMonteCarlo.isapplicable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapplicable(x::AbstractConfig, move::AbstractArray, HilbertSpace::AbstractHilbertSpace)</code></pre><p>Check if a given move is applicable to the current configuration within a specified Hilbert space.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: The current configuration.</li><li><code>move::AbstractMove</code>: The proposed move to be applied.</li><li><code>HilbertSpace::AbstractHilbertSpace</code>: The Hilbert space in which the configuration and move are defined.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the move is applicable, <code>false</code> otherwise.</li></ul><p>Defaults to applying the move to the configuration, checking if the constraints are satisfied, and then reverting the move.</p><p>Make sure to implement this function for specific subtypes of <code>AbstractConfig</code> and <code>AbstractHilbertSpace</code> to ensure optimal performance. See also <code>isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L93-L110">source</a></section><section><div><pre><code class="language-julia hljs">isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint) -&gt; Bool</code></pre><p>Check if a given move is applicable to a configuration under a specified constraint.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractConfig</code>: The configuration to which the move will be applied.</li><li><code>move::AbstractMove</code>: The move that is being checked for applicability.</li><li><code>constraint::AbstractConstraint</code>: The constraint that must be satisfied for the move to be applicable.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the move is applicable to the configuration under the given constraint, <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractOperator.jl#L116-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.minimizeReconfiguration!" href="#GreenFunctionMonteCarlo.minimizeReconfiguration!"><code>GreenFunctionMonteCarlo.minimizeReconfiguration!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>given a list of reconfiguration indices, minimizes the number of reconfigurations by swapping elements in the list. Each walker that survives a reconfiguration step remains unchanged while walkers that are killed get assigned to a new index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Reconfiguration/MinimalReconfiguration.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.pre_move_affect!" href="#GreenFunctionMonteCarlo.pre_move_affect!"><code>GreenFunctionMonteCarlo.pre_move_affect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Updates the guiding function buffer before any move is applied.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractGuidingFunctions.jl#L86-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.ProblemEnsemble" href="#GreenFunctionMonteCarlo.ProblemEnsemble"><code>GreenFunctionMonteCarlo.ProblemEnsemble</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProblemEnsemble{P&lt;:AbstractGFMCProblem} &lt;: AbstractGFMCProblem</code></pre><p>Run multiple GFMC problems in parallel. Useful to estimate errors.</p><p><strong>Usage example:</strong></p><pre><code class="nohighlight hljs">P = ProblemEnsemble([GFMCProblem1, GFMCProblem2, ...])

problems = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for _ in 1:10])

Observers = [ConfigObserver(&quot;output_$i.h5&quot;,startConfig, NSteps, NWalkers) for i in 1:10] #note that each observer must have its own file

runGFMC!(problems, NoObserver(),100) #equilibrate
runGFMC!(problems, Observers)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ManyWalkerGFMC.jl#L203-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.propagateWalkers!" href="#GreenFunctionMonteCarlo.propagateWalkers!"><code>GreenFunctionMonteCarlo.propagateWalkers!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Propagates walker ensemble <code>X</code> using a collection of moves according to the rules specified by the propagator <code>P</code>. </p><p><strong>Usage:</strong></p><p><code>propagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/AbstractTypes/AbstractPropagator.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.reconfigurateWalkers!" href="#GreenFunctionMonteCarlo.reconfigurateWalkers!"><code>GreenFunctionMonteCarlo.reconfigurateWalkers!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Performs an efficient reconfiguration of walkers. This reconfiguration will not remove walkers if they all have the same weight, which increases the efficiency as more walkers can contribute to the average.</p><p>Matteo Calandra Buonaura and Sandro Sorella Phys. Rev. B 57, 11446 (1998)</p><p><strong>Arguments</strong></p><ul><li><code>Walkers::AbstractWalkerEnsemble</code>: The ensemble of walkers to be reconfigured.</li><li><code>reconfigurationList</code>: A list of indices that will be reconfigured.</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/Reconfiguration/MinimalReconfiguration.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GreenFunctionMonteCarlo.runGFMC!" href="#GreenFunctionMonteCarlo.runGFMC!"><code>GreenFunctionMonteCarlo.runGFMC!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runGFMC!(Walkers::AbstractWalkerEnsemble, Observables::AbstractObserver, reconfiguration::AbstractReconfigurationScheme, 
         range, propagator::AbstractPropagator, logψ::AbstractGuidingFunction, H::AbstractSignFreeOperator, 
         Hilbert::AbstractHilbertSpace, parallelizer::AbstractParallelizationScheme, logger::AbstractLogger, RNG::Random.AbstractRNG)</code></pre><p>Runs the Green Function Monte Carlo (GFMC) simulation for a given system.</p><p><strong>Arguments</strong></p><ul><li><code>Walkers::AbstractWalkerEnsemble</code>: The ensemble of walkers representing the quantum state.</li><li><code>Observables::AbstractObserver</code>: The observer object used to measure physical quantities during the simulation.</li><li><code>reconfiguration::AbstractReconfigurationScheme</code>: The scheme used to reconfigure the walker ensemble to maintain population control.</li><li><code>range</code>: The range of iterations or time steps for the simulation.</li><li><code>propagator::AbstractPropagator</code>: The propagator used to evolve the walkers.</li><li><code>logψ::AbstractGuidingFunction</code>: The guiding function (logarithmic form) used for importance sampling.</li><li><code>H::AbstractSignFreeOperator</code>: The Hamiltonian operator of the system, assumed to be sign-free.</li><li><code>Hilbert::AbstractHilbertSpace</code>: The Hilbert space on which the system is defined.</li><li><code>parallelizer::AbstractParallelizationScheme</code>: The parallelization scheme used to distribute computation across resources.</li><li><code>logger::AbstractLogger</code>: The logger object used to record simulation progress.</li><li><code>RNG::Random.AbstractRNG</code>: The random number generator used for stochastic processes in the simulation.</li></ul><p><strong>Description</strong></p><p>This function performs the GFMC simulation by evolving the walker ensemble using the provided propagator and guiding function. It measures observables diagonal in the computational Basis at each step and applies reconfiguration to control the walker population. The simulation is parallelized according to the specified parallelization scheme.</p><p><strong>Notes</strong></p><ul><li>The function modifies the <code>Walkers</code> object in place.</li><li>Ensure that all input objects are properly initialized before calling this function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ManyWalkerGFMC.jl#L60-L86">source</a></section><section><div><pre><code class="language-julia hljs">runGFMC!(prob::GFMCProblem, Observables::AbstractObserver, range; logger = NoLogger(), rng = Random.default_rng())</code></pre><p>Run the Green&#39;s Function Monte Carlo (GFMC) simulation for the given problem.</p><p><strong>Arguments</strong></p><ul><li><code>prob::GFMCProblem</code>: The GFMC problem instance containing the system configuration and parameters.</li><li><code>Observables::AbstractObserver</code>: An observer object to track and record observables during the simulation.</li><li><code>range</code>: Integer or range: The range of iterations or steps over which the simulation will be performed.</li><li><code>logger</code>: (Optional) A logger instance for logging simulation progress. Defaults to <code>ProgressBarLogger(dt=0.1)</code>. Use <code>NoLogger()</code> or <code>nothing</code> to disable logging.</li><li><code>rng</code>: (Optional) A random number generator to ensure reproducibility. Defaults to <code>Random.default_rng()</code>.</li></ul><p><strong>Returns</strong></p><p>This function modifies the <code>prob</code> and <code>Observables</code> in place to reflect the results of the simulation.</p><p><strong>Notes</strong></p><p>Ensure that the <code>prob</code> and <code>Observables</code> are properly initialized before calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl/blob/5417d91471c1d5de7f6abc629876a8ebaaeec11d/src/DefaultFormalism/ManyWalkerGFMC.jl#L175-L192">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Example_transverseFieldIsing/">« Example: Transverse Field Ising Model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Thursday 27 March 2025 15:39">Thursday 27 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
