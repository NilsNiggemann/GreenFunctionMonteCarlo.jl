var documenterSearchIndex = {"docs":
[{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"GreenFunctionMonteCarlo.AbstractConfig\nGreenFunctionMonteCarlo.AbstractConstraint\nGreenFunctionMonteCarlo.AbstractDiagObservable\nGreenFunctionMonteCarlo.AbstractGFMCProblem\nGreenFunctionMonteCarlo.AbstractGuidingFunction\nGreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer\nGreenFunctionMonteCarlo.AbstractHilbertSpace\nGreenFunctionMonteCarlo.AbstractMove\nGreenFunctionMonteCarlo.AbstractObserver\nGreenFunctionMonteCarlo.AbstractOperator\nGreenFunctionMonteCarlo.AbstractPropagator\nGreenFunctionMonteCarlo.AbstractReconfigurationScheme\nGreenFunctionMonteCarlo.AbstractSignFreeOperator\nGreenFunctionMonteCarlo.AbstractWalkerEnsemble\nGreenFunctionMonteCarlo.BasicObserver\nGreenFunctionMonteCarlo.CombinedObserver\nGreenFunctionMonteCarlo.ConfigObserver\nGreenFunctionMonteCarlo.ConfigurationObserver\nGreenFunctionMonteCarlo.DiagonalOperator\nGreenFunctionMonteCarlo.EqualWeightSuperposition\nGreenFunctionMonteCarlo.GFMCProblem\nGreenFunctionMonteCarlo.GreenFunctionMonteCarlo\nGreenFunctionMonteCarlo.InverseMove\nGreenFunctionMonteCarlo.Jastrow\nGreenFunctionMonteCarlo.NaiveFunction\nGreenFunctionMonteCarlo.NoLogger\nGreenFunctionMonteCarlo.NoObserver\nGreenFunctionMonteCarlo.ProgressBarLogger\nGreenFunctionMonteCarlo.SimpleLogger\nGreenFunctionMonteCarlo.allocate_GWF_buffers\nGreenFunctionMonteCarlo.apply!\nGreenFunctionMonteCarlo.continuos_time_propagation!\nGreenFunctionMonteCarlo.fulfills_constraint\nGreenFunctionMonteCarlo.get_move\nGreenFunctionMonteCarlo.get_offdiagonal_elements\nGreenFunctionMonteCarlo.isapplicable\nGreenFunctionMonteCarlo.minimizeReconfiguration!\nGreenFunctionMonteCarlo.pre_move_affect!\nGreenFunctionMonteCarlo.ProblemEnsemble\nGreenFunctionMonteCarlo.propagateWalkers!\nGreenFunctionMonteCarlo.reconfigurateWalkers!\nGreenFunctionMonteCarlo.runGFMC!","category":"page"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractConfig","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractConfig","text":"AbstractConfig{T,N}\n\nAn abstract type that represents a configuration (i.e. spins, bosons on a lattice).  This type is a subtype of AbstractArray{T,N}.\n\nParameters\n\nT: The type of the elements in the configuration.\nN: The number of dimensions of the configuration.\n\nInterface\n\nBase.parent(x::AbstractConfig): return the parent array\nBase.copy(x::AbstractConfig): create a full copy of the configuration\napply!(x::AbstractConfig, move::Any): apply a move to the configuration\nfulfills_constraints(x::AbstractConfig, HilbertSpace::AbstractHilbertSpace): check if the configuration satisfies the constraints of the Hilbert space\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractConstraint","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractConstraint","text":"AbstractConstraint\n\nAn abstract type representing a constraint in the context of a Hilbert space.\n\nInterface\n\n(c)(x::AbstractArray): Check if the configuration x satisfies the constraint.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractDiagObservable","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractDiagObservable","text":"Abstract supertype for observables which are diagonal in the computational basis and may be measured for free in GFMC. An observable must be a function that takes a configuration and returns an array.\n\nInterface:\n\nobs(::O) returns the buffer array for the output of the observable.\nO(out,Conf): Writes the observable for the given configuration to the preallocated array out. Returns out.\nBase.copy(O::O): Returns a copy of the observable.\n\nIf no preallocated array is given, the observable defaults to using the buffer array obs(O).\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGFMCProblem","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGFMCProblem","text":"Abstract type for GFMC problems.\n\nInterface:\n\nrunGFMC!(problem::AbstractGFMCProblem,args...;kwargs...): Run the GFMC algorithm for the given problem.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGuidingFunction","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGuidingFunction","text":"AbstractGuidingFunction\n\nAn abstract type for all guiding function implementations in Green Function Monte Carlo. Subtypes of this correspond to implementations of concrete guiding functions, particularly variational wavefunctions. For optimal performance, it is recommended to implement the function logpsidiff! for the specific guiding function type.\n\nInterface\n\nlogψ(x::AbstractArray): return the logarithm of the guiding function evaluated at the configuration x.\nlogψ(x::AbstractArray, H::AbstractHilbertSpace): return the logarithm of the guiding function evaluated at the configuration x in the specified HilbertSpace.\nlog_psi_diff(x::AbstractArray, dx::AbstractArray, logψ::AbstractGuidingFunction, Buffer::AbstractGuidingFunctionBuffer, Hilbert::AbstractHilbertSpace): return the logarithm of the ratio of the guiding function evaluated at the configuration x and x+dx in the specified HilbertSpace. Returns -Inf if the move is not applicable.\nget_params(logψ::AbstractGuidingFunction): return the parameters of the guiding function as a linear Array. It is recommended to use RecursiveArrayTools.jl for this purpose.\nHDF5.h5write(file::AbstractString, name::AbstractString, logψ::AbstractGuidingFunction): write the guiding function to an HDF5 file.\n\nInterface (optional)\n\nallocateGWFbuffers(logψ::AbstractGuidingFunction, NBuffers::Integer): allocate NBuffers instances of a buffer for the guiding function. Defaults to an array of EmptyGWFBuffer instances.\ncomputeGWFbuffer!(Buffer::AbstractGuidingFunctionBuffer, logψ::AbstractGuidingFunction, x): compute the full buffer for the guiding function at the configuration x. \npremoveaffect!(Buffer::AbstractGuidingFunctionBuffer, x, moves, logψ::AbstractGuidingFunction): perform any necessary operations before computing ratios ψx´_ψx.\npostmoveaffect!(Buffer::AbstractGuidingFunctionBuffer, x, dx, logψ::AbstractGuidingFunction): perform any necessary operations after the move is applied.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","text":"AbstractGuidingFunctionBuffer\n\nAn abstract type that serves as a base for defining guiding function buffer structures. \n\nInterface\n\nsetBuffer!(BA::AbstractGuidingFunctionBuffer, BB::AbstractGuidingFunctionBuffer): set the buffer BA to the values of the buffer BB.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractHilbertSpace","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractHilbertSpace","text":"AbstractHilbertSpace\n\nAn abstract type representing a Hilbert space. This type serves as a base for defining various specific Hilbert spaces used in the project. Generally, a hilbert space should be defined by the number of sites, the number of local degrees of freedom (i.e. spin), and the constraint that the configurations must satisfy. \n\nInterface\n\nconstraint(HilbertSpace::AbstractHilbertSpace): Return the constraint that the configurations in the Hilbert space must satisfy.\nBase.size(HilbertSpace::AbstractHilbertSpace): Return the size of a config in the Hilbert space.\n\nInterface (optional)\n\nfulfills_constraint(x,HilbertSpace::AbstractHilbertSpace): Check if the given configuration x satisfies the constraint of the specified HilbertSpace. Defaults to constraint(HilbertSpace)(x).\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractMove","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractMove","text":"AbstractMove\n\nAbstract type representing a move, i.e. an operation that changes a configuration x to a new configuration x'.\n\nAbstract type representing a move operation in the context of Green Function Monte Carlo simulations.\n\nThis abstract type serves as a base for defining various move operations that can be performed during the simulation process. Specific move types should inherit from this abstract type and implement the required functionality.\n\nInterface\n\napply!(x::AbstractConfig, move::AbstractMove): Apply the move to the configuration x.\nisapplicable(x::AbstractConfig, move::AbstractMove, HilbertSpace::AbstractHilbertSpace): Check if the move is applicable to the configuration x within the specified HilbertSpace.\naffected_sites(move::AbstractMove): Return the sites affected by the move.\nmove_dx(move::AbstractMove,x::AbstractConfig): Return the values of the move applied to the configuration x. i.e. the change in x when the move is applied.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractObserver","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractObserver","text":"Abstract supertype for observables in GFMC which are recorded during the run. Observables should always contain the table recording reconfiguration processes, the energies, and the total weights of each Markov step.\n\nInterface:\n\nsaveObservables_before!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers.\nsaveObservables_after!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers after reconfiguration.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractOperator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractOperator","text":"AbstractOperator\n\nAn abstract type representing a general operator. This serves as a base type for defining various specific operators in the context of the Green Function Monte Carlo project.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractPropagator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractPropagator","text":"AbstractPropagator\n\nAn abstract type representing a propagator. Examples include discrete or continuous time methods.\n\nInterface:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng()): Propagate the walkers in the ensemble using the specified moves and parameters.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractReconfigurationScheme","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractReconfigurationScheme","text":"AbstractReconfigurationScheme\n\nAn abstract type that serves as a base for defining different reconfiguration strategies  in the context of the Green Function Monte Carlo framework. \n\nInterface\n\nreconfigurateWalkers!(Walkers::AbstractWalkerEnsemble,reconfiguration::AbstractReconfigurationScheme,rng::Random.AbstractRNG)\nget_reconfigurationList(reconfiguration::AbstractReconfigurationScheme)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractSignFreeOperator","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractSignFreeOperator","text":"AbstractSignFreeOperator <: AbstractOperator\n\nAn abstract type representing a sign-free operator in the context of Green Function Monte Carlo simulations. \n\nInterface:\n\nget_diagonal(O::AbstractSignFreeOperator): return the diagonal operator associated with the sign-free operator O\ngetoffdiagonalelements(O::AbstractSignFreeOperator): return the weights associated with the off-diagonal operator O\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.AbstractWalkerEnsemble","page":"Reference","title":"GreenFunctionMonteCarlo.AbstractWalkerEnsemble","text":"AbstractWalkerEnsemble\n\nAn abstract type that represents an ensemble of configurations (i.e. spins, bosons on a lattice for each walker) in the context of the Green Function Monte Carlo project. \n\nInterface (required)\n\ngetConfig(X::AbstractWalkerEnsemble,α):  get the configuration of the α-th walker in the ensemble.\ngetMoveWeights(X::AbstractWalkerEnsemble,α): get the weights of the moves for the α-th walker in the ensemble.\ngetBuffer(X::AbstractWalkerEnsemble,α): get the buffer associated with the α-th walker in the ensemble.\ngetWalkerWeights(X::AbstractWalkerEnsemble): get the weights of the Walkers in the ensemble.\n\nInterface (optional)\n\nBase.eachindex(X::AbstractWalkerEnsemble): iterate over the indices of the ensemble.\ngetNWalkers(X::AbstractWalkerEnsemble): get the number of walkers in the ensemble.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.BasicObserver","page":"Reference","title":"GreenFunctionMonteCarlo.BasicObserver","text":"struct BasicObserver{DT<:AbstractFloat} <: AbstractObserver\n\nSaves the energies, weights and reconfigurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the energies and weights.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.CombinedObserver","page":"Reference","title":"GreenFunctionMonteCarlo.CombinedObserver","text":"CombinedObserver{T}\n\nA struct that represents a combined observer, which is a collection of multiple observers grouped together.  This allows for observing multiple quantities or behaviors simultaneously.\n\nFields\n\nObservers::T: A collection containing the individual observers.\n\nUsage\n\nThis struct is useful for combining multiple observer objects into a single entity, enabling them to be managed and used collectively.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ConfigObserver","page":"Reference","title":"GreenFunctionMonteCarlo.ConfigObserver","text":"ConfigObserver(filename, config::AbstractConfig{T,N}, NSteps::Integer, NWalkers::Integer) where {T,N}\n\nCreates a combined observer that tracks energy, weight, reconfigurations and configurations of the walkers during the Monte Carlo simulation. The observer saves the data to a file with the given filename.\n\nArguments\n\nfilename::String: The name of the file where the configuration data will be saved.\nconfig::AbstractConfig{T,N}: The initial configuration object representing the system state.\nNSteps::Integer: The number of simulation steps to be observed.\nNWalkers::Integer: The number of walkers (or particles) in the simulation.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.ConfigurationObserver","page":"Reference","title":"GreenFunctionMonteCarlo.ConfigurationObserver","text":"struct ConfigurationObserver{T} <: AbstractObserver\n\nSaves the configurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the configurations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.DiagonalOperator","page":"Reference","title":"GreenFunctionMonteCarlo.DiagonalOperator","text":"DiagonalOperator\n\nAn abstract type representing a diagonal operator in the context of Green Function Monte Carlo simulations. A diagonal operator is special in the sense that it will not change the configuration of the system when applied to it and will only return a number.\n\nInterface:\n\n(D::DiagonalOperator)(x) : return the value of the operator applied to the configuration x\n(D::DiagonalOperator)(x, params): return the value of the operator applied to the configuration x with parameters params, which can be used to store buffers.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.EqualWeightSuperposition","page":"Reference","title":"GreenFunctionMonteCarlo.EqualWeightSuperposition","text":"struct EqualWeightSuperposition <: AbstractGuidingFunction\n\nRepresents a guiding function that models an equal weight superposition of states, i.e. ψ(x) = 1 for all x, provided that the configuration x is a valid configuration satisfying all constraints. This structure is a subtype of AbstractGuidingFunction and is used in the context of variational calculations within the Green Function Monte Carlo framework.\n\nSee Also\n\nAbstractGuidingFunction: The abstract type that this struct extends.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.GFMCProblem","page":"Reference","title":"GreenFunctionMonteCarlo.GFMCProblem","text":"struct GFMCProblem{WE<:AbstractWalkerEnsemble, Prop<:AbstractPropagator, GF<:AbstractGuidingFunction, \n                 SFO<:AbstractSignFreeOperator, HS<:AbstractHilbertSpace, PS<:AbstractParallelizationScheme, \n                 RS<:AbstractReconfigurationScheme} <: AbstractGFMCProblem\n\nRepresents a Green's Function Monte Carlo (GFMC) problem with the following type parameters:\n\nWE<:AbstractWalkerEnsemble: The type of the walker ensemble used in the simulation.\nProp<:AbstractPropagator: The propagator responsible for evolving the system.\nGF<:AbstractGuidingFunction: The guiding function used to improve the efficiency of the simulation.\nSFO<:AbstractSignFreeOperator: The operator ensuring sign-free sampling in the simulation, containing only negative elements on the off-diagonal.\nHS<:AbstractHilbertSpace: The Hilbert space in which the problem is defined.\nPS<:AbstractParallelizationScheme: The parallelization scheme used for distributing computation.\nRS<:AbstractReconfigurationScheme: The reconfiguration scheme used to manage walker populations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","page":"Reference","title":"GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","text":"GreenFunctionMonteCarlo.jl\n\n(Image: build) (Image: Documentation) <!– Tidyverse lifecycle badges, see https://www.tidyverse.org/lifecycle/ Uncomment or delete as needed. –> (Image: lifecycle)<!– (Image: lifecycle) (Image: lifecycle) (Image: lifecycle) (Image: lifecycle) (Image: lifecycle) –>\n\n<!– (Image: GitHub commits since tagged version) –> <!– (Image: Documentation) –>\n\n<!– Aqua badge, see test/runtests.jl –> <!– (Image: Aqua QA) –>\n\n<!– travis-ci.com badge, uncomment or delete as needed, depending on whether you are using that service. –> <!– (Image: Build Status) –> <!– NOTE: Codecov.io badge now depends on the token, copy from their site after setting up –> <!– Documentation – uncomment or delete as needed –> <!– START README (DO NOT DELETE THIS LINE!) –>\n\nOverview\n\nGreenFunctionMonteCarlo.jl is a Julia package designed for performing Green Function Monte Carlo (GFMC) simulations on lattice models.\n\nPresently, this package treats only Hamiltonians that are free of the sign problem, i.e. whose elements satisfy\n\n\nH_x x leq 0 quad forall x neq x\n\nwhere H_x x is the matrix element of the Hamiltonian between two configurations (spins or bosons) x and x. \n\nFeatures\n\n[x] Efficient implementation of the fixed-walker formalism for general systems of interacting bosons [1].\n[x] Flexible framework for implementation of other algorithms.\n[x] Constraints, such as hardcore boson constraint.\n[x] Interface for the efficient implementation of arbitrary constraints.\n[ ] Measure arbitrary observables in the diagonal basis.\n[ ] Measure offdiagonal observables via straight-forward walking.\n[ ] Allow more direct implementation of spin models.\n[ ] Allow for easy conversions of Hamiltonians and variational wavefunctions from Netket.\n\nLimitations\n\nThe package is currently in the experimental stage and exported functionality may change or break in the future.\nCurrently, there is no implementation of the fixed-node approximation [2] for Hamiltonians with the sign problem.\n\nInstallation\n\nTo install the package, use the Julia package manager:\n\nusing Pkg\nPkg.add(url = \"https://github.com/NilsNiggemann/GreenFunctionMonteCarlo.jl.git\")\n\nDocumentation\n\nFor detailed documentation, including API references and advanced usage, visit the documentation site.\n\nContributing\n\nContributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.\n\nLicense\n\nThis project is licensed under the MIT License. See the LICENSE file for details.\n\nReferences:\n\n[1] Buonaura, M. & Sorella, S. Green's function Monte Carlo method for lattice fermions. Phys. Rev. B 57, 11446 (1998).\n[2] Becca, F. & Sorella, S. Quantum Monte Carlo Approaches for Correlated Systems. Cambridge University Press; 2017.\n\n\n\n\n\n","category":"module"},{"location":"Reference/#GreenFunctionMonteCarlo.InverseMove","page":"Reference","title":"GreenFunctionMonteCarlo.InverseMove","text":"struct InverseMove{T<:AbstractMove} <: AbstractMove\n\nA type representing an inverse move in a Monte Carlo simulation. This type is parameterized by T, which must be a subtype of AbstractMove. The InverseMove struct is used to encapsulate the concept of an inverse operation corresponding to a given move in the simulation.\n\nParameters\n\nT: A subtype of AbstractMove that specifies the type of move for which this struct represents the inverse.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.Jastrow","page":"Reference","title":"GreenFunctionMonteCarlo.Jastrow","text":"struct Jastrow{T<:Real} <: AbstractGuidingFunction\n\nA structure representing the Jastrow factor in a variational Monte Carlo simulation. This function strikes a good balance between accuracy and computational efficiency in the context of Green Function Monte Carlo. log(ψ(x)) = sum_i m_i x_i + frac12sum_ij v_ij x_i x_j\n\nType Parameters\n\nT<:Real: The numeric type used for the parameters of the Jastrow factor  (e.g., Float64, Float32).\n\nUsage\n\nlogψ = Jastrow(N,Float64) # Create a Jastrow factor for N sites with parameters of type Float64. logψ = Jastrow(conf,Float64) # Create a Jastrow factor for configurations similar to conf.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NaiveFunction","page":"Reference","title":"GreenFunctionMonteCarlo.NaiveFunction","text":"provides a naive wrapper for a guiding function which does not use any buffer. Useful for debugging and testing\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NoLogger","page":"Reference","title":"GreenFunctionMonteCarlo.NoLogger","text":"NoLogger <: AbstractLogger\n\nA placeholder implementation that does not perform any logging.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.NoObserver","page":"Reference","title":"GreenFunctionMonteCarlo.NoObserver","text":"NoObserver <: AbstractObserver\n\nAn observer type that does not save anything. Can be used to evolve the system in the most efficient way, i.e. for equilibration.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.ProgressBarLogger","page":"Reference","title":"GreenFunctionMonteCarlo.ProgressBarLogger","text":"ProgressBarLogger(; kwargs...)\n\nCreates a progress bar logger with customizable update intervals and additional options.\n\nArguments\n\nkwargs...: Additional keyword arguments to customize the behavior of the progress bar logger. See GreenFunctionMonteCarlo.ProgressMeter.Progress for more details.\n\nReturns\n\nA progress bar logger instance that can be used to track and display progress in a task.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.SimpleLogger","page":"Reference","title":"GreenFunctionMonteCarlo.SimpleLogger","text":"struct SimpleLogger <: AbstractLogger\n\nA simple logger implementation that inherits from AbstractLogger.\n\nFields\n\nn_report::Int: The number of steps in the log report.\n\nThis logger can be used to control and manage logging behavior in a straightforward manner.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.allocate_GWF_buffers","page":"Reference","title":"GreenFunctionMonteCarlo.allocate_GWF_buffers","text":"allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer, x)\n\nAllocates a specified number of guiding wave function (GWF) buffers.\n\nArguments\n\nlogψ::AbstractGuidingFunction: The guiding function for which the buffers are being allocated.\nNBuffers::Integer: The number of buffers to allocate.\nx: An exemplary configuration\n\nReturns\n\nAn array filled with NBuffers instances of AbstractGuidingFunctionBuffer. Defaults to an array of NotImplementedBuffer instances.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.apply!","page":"Reference","title":"GreenFunctionMonteCarlo.apply!","text":"apply!(x::AbstractConfig, move::AbstractMove)\n\nThrows a MethodError indicating that the apply! function has not been implemented for the given AbstractConfig type and move.\n\nArguments\n\nx::AbstractConfig: An instance of a type that is a subtype of AbstractConfig.\nmove::AbstractMove: A move or operation to be applied to the configuration x.\n\nThrows\n\nMethodError: Always thrown to indicate that the method needs to be implemented for specific subtypes of AbstractConfig.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.continuos_time_propagation!","page":"Reference","title":"GreenFunctionMonteCarlo.continuos_time_propagation!","text":"continuos_time_propagation!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, dτ::Real, parallelization::MultiThreaded, RNG::Random.AbstractRNG = Random.default_rng())\n\nPerform continuous time propagation on a walker ensemble for a fixed time step dτ.\n\nArguments\n\nWE::AbstractWalkerEnsemble: The ensemble of walkers to be propagated.\nH::AbstractSignFreeOperator: The Hamiltonian operator used for propagation.\nlogψ::AbstractGuidingFunction: The guiding function for the propagation.\nHilbert::AbstractHilbertSpace: The Hilbert space in which the propagation occurs.\ndτ::Real: The time step for the propagation.\nw_avg_estimate::Real: An estimate of the average weight.\nparallelization::MultiThreaded: Parallelization settings for the propagation.\nRNG::Random.AbstractRNG: The random number generator to be used (default is Random.default_rng()).\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.fulfills_constraint","page":"Reference","title":"GreenFunctionMonteCarlo.fulfills_constraint","text":"fulfills_constraint(x::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if the given configuration x satisfies the constraint of the specified HilbertSpace.\n\nArguments\n\nx::AbstractArray: The configuration to be checked.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space whose constraint need to be satisfied.\n\nReturns\n\nBool: true if the configuration satisfies the constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.get_move","page":"Reference","title":"GreenFunctionMonteCarlo.get_move","text":"get_move(O::AbstractOperator,idx::Integer)\n\nReturn the move associated with the operator O at index idx. \n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.get_offdiagonal_elements","page":"Reference","title":"GreenFunctionMonteCarlo.get_offdiagonal_elements","text":"get_offdiagonal_elements(O::AbstractSignFreeOperator)\n\nReturn the weights associated with an AbstractSignFreeOperator object O. \n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.isapplicable","page":"Reference","title":"GreenFunctionMonteCarlo.isapplicable","text":"isapplicable(x::AbstractConfig, move::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if a given move is applicable to the current configuration within a specified Hilbert space.\n\nArguments\n\nx::AbstractConfig: The current configuration.\nmove::AbstractMove: The proposed move to be applied.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space in which the configuration and move are defined.\n\nReturns\n\nBool: true if the move is applicable, false otherwise.\n\nDefaults to applying the move to the configuration, checking if the constraints are satisfied, and then reverting the move.\n\nMake sure to implement this function for specific subtypes of AbstractConfig and AbstractHilbertSpace to ensure optimal performance. See also isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint).\n\n\n\n\n\nisapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint) -> Bool\n\nCheck if a given move is applicable to a configuration under a specified constraint.\n\nArguments\n\nx::AbstractConfig: The configuration to which the move will be applied.\nmove::AbstractMove: The move that is being checked for applicability.\nconstraint::AbstractConstraint: The constraint that must be satisfied for the move to be applicable.\n\nReturns\n\nBool: true if the move is applicable to the configuration under the given constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.minimizeReconfiguration!","page":"Reference","title":"GreenFunctionMonteCarlo.minimizeReconfiguration!","text":"given a list of reconfiguration indices, minimizes the number of reconfigurations by swapping elements in the list. Each walker that survives a reconfiguration step remains unchanged while walkers that are killed get assigned to a new index.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.pre_move_affect!","page":"Reference","title":"GreenFunctionMonteCarlo.pre_move_affect!","text":"Updates the guiding function buffer before any move is applied.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.ProblemEnsemble","page":"Reference","title":"GreenFunctionMonteCarlo.ProblemEnsemble","text":"ProblemEnsemble{P<:AbstractGFMCProblem} <: AbstractGFMCProblem\n\nRun multiple GFMC problems in parallel. Useful to estimate errors.\n\nUsage example:\n\nP = ProblemEnsemble([GFMCProblem1, GFMCProblem2, ...])\n\nproblems = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for _ in 1:10])\n\nObservers = [ConfigObserver(\"output_$i.h5\",startConfig, NSteps, NWalkers) for i in 1:10] #note that each observer must have its own file\n\nrunGFMC!(problems, NoObserver(),100) #equilibrate\nrunGFMC!(problems, Observers)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#GreenFunctionMonteCarlo.propagateWalkers!","page":"Reference","title":"GreenFunctionMonteCarlo.propagateWalkers!","text":"Propagates walker ensemble X using a collection of moves according to the rules specified by the propagator P. \n\nUsage:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.reconfigurateWalkers!","page":"Reference","title":"GreenFunctionMonteCarlo.reconfigurateWalkers!","text":"Performs an efficient reconfiguration of walkers. This reconfiguration will not remove walkers if they all have the same weight, which increases the efficiency as more walkers can contribute to the average.\n\nMatteo Calandra Buonaura and Sandro Sorella Phys. Rev. B 57, 11446 (1998)\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers to be reconfigured.\nreconfigurationList: A list of indices that will be reconfigured.\nrng::Random.AbstractRNG: The random number generator to be used.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#GreenFunctionMonteCarlo.runGFMC!","page":"Reference","title":"GreenFunctionMonteCarlo.runGFMC!","text":"runGFMC!(Walkers::AbstractWalkerEnsemble, Observables::AbstractObserver, reconfiguration::AbstractReconfigurationScheme, \n         range, propagator::AbstractPropagator, logψ::AbstractGuidingFunction, H::AbstractSignFreeOperator, \n         Hilbert::AbstractHilbertSpace, parallelizer::AbstractParallelizationScheme, logger::AbstractLogger, RNG::Random.AbstractRNG)\n\nRuns the Green Function Monte Carlo (GFMC) simulation for a given system.\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers representing the quantum state.\nObservables::AbstractObserver: The observer object used to measure physical quantities during the simulation.\nreconfiguration::AbstractReconfigurationScheme: The scheme used to reconfigure the walker ensemble to maintain population control.\nrange: The range of iterations or time steps for the simulation.\npropagator::AbstractPropagator: The propagator used to evolve the walkers.\nlogψ::AbstractGuidingFunction: The guiding function (logarithmic form) used for importance sampling.\nH::AbstractSignFreeOperator: The Hamiltonian operator of the system, assumed to be sign-free.\nHilbert::AbstractHilbertSpace: The Hilbert space on which the system is defined.\nparallelizer::AbstractParallelizationScheme: The parallelization scheme used to distribute computation across resources.\nlogger::AbstractLogger: The logger object used to record simulation progress.\nRNG::Random.AbstractRNG: The random number generator used for stochastic processes in the simulation.\n\nDescription\n\nThis function performs the GFMC simulation by evolving the walker ensemble using the provided propagator and guiding function. It measures observables diagonal in the computational Basis at each step and applies reconfiguration to control the walker population. The simulation is parallelized according to the specified parallelization scheme.\n\nNotes\n\nThe function modifies the Walkers object in place.\nEnsure that all input objects are properly initialized before calling this function.\n\n\n\n\n\nrunGFMC!(prob::GFMCProblem, Observables::AbstractObserver, range; logger = NoLogger(), rng = Random.default_rng())\n\nRun the Green's Function Monte Carlo (GFMC) simulation for the given problem.\n\nArguments\n\nprob::GFMCProblem: The GFMC problem instance containing the system configuration and parameters.\nObservables::AbstractObserver: An observer object to track and record observables during the simulation.\nrange: Integer or range: The range of iterations or steps over which the simulation will be performed.\nlogger: (Optional) A logger instance for logging simulation progress. Defaults to ProgressBarLogger(dt=0.1). Use NoLogger() or nothing to disable logging.\nrng: (Optional) A random number generator to ensure reproducibility. Defaults to Random.default_rng().\n\nReturns\n\nThis function modifies the prob and Observables in place to reflect the results of the simulation.\n\nNotes\n\nEnsure that the prob and Observables are properly initialized before calling this function.\n\n\n\n\n\n","category":"function"},{"location":"Example_transverseFieldIsing/#Example:-Transverse-Field-Ising-Model","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"","category":"section"},{"location":"Example_transverseFieldIsing/#Defining-the-Hamiltonian","page":"Example: Transverse Field Ising Model","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"The transverse field Ising model is a quantum spin model that exhibits a quantum phase transition. The Hamiltonian for the model is given by:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"H = -J sum_langle i j rangle sigma_i^z sigma_j^z - h sum_i sigma_i^x","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"where:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"J is the interaction strength between neighboring spins.\nh is the transverse field strength.\nsigma^z and sigma^x are Pauli matrices.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"Below is an example of how to simulate the transverse field Ising model using GreenFunctionMonteCarlo.jl:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"First, we implement our Hamiltonian. Since our problem is equivalent to a hardcore boson problem, we represent our spin configurations by Booleans for optimal performance.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"using GreenFunctionMonteCarlo\n\nσz(n::Bool) = (1 - 2 * n)\nσz(i, conf::AbstractArray) = σz(conf[i])\n\nfunction transverse_field_ising(Nsites, h, J; periodic = false)\n    Hilbert = BosonHilbertSpace(Nsites, HardCoreConstraint())\n\n    moves = [Bool[0 for _ in 1:Nsites] for _ in 1:Nsites]\n    offdiagElements = zeros(Float64, Nsites)\n\n    for i in eachindex(moves)\n        moves[i][i] = true\n        offdiagElements[i] = -h\n    end\n\n    function Hxx(conf)\n        E = -J * sum(σz(i, conf) * σz(i + 1, conf) for i in eachindex(conf)[1:end-1])\n        if periodic\n            E += -J * σz(Nsites, conf) * σz(1, conf)\n        end\n        return E\n    end\n\n    H = localOperator(moves, offdiagElements, DiagOperator(Hxx), Hilbert)\n    return (; Hilbert, H)\nend\n\n# Define parameters\nJ = 1.0       # Interaction strength\nh = 1.0       # Transverse field strength\nlattice_size = 6  # Number of spins\nperiodic = false  # No periodic boundary conditions\n# Define the Hamiltonian\n(;Hilbert,H) = transverse_field_ising(lattice_size, h, J; periodic)","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"The Hamiltonian is split into a diagonal and an offdiagonal part. The diagonal H_xxprime can be an arbitray function of the configuration x. The offdiagonal is given by the moves and offdiagElements arrays. The moves array contains the indices of the spins that are flipped, while the offdiagElements array contains the corresponding weights for each move.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"note: Note\nThe moves can also be given by Integers, i.e. Int8[0,0,...,-1,1,0,...,0] for a term sigma_i^- sigma_i+1^+. This will be slower, but allows for more complex moves.","category":"page"},{"location":"Example_transverseFieldIsing/#Running-the-Simulation","page":"Example: Transverse Field Ising Model","title":"Running the Simulation","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"We now proceed to solve the Hamiltonian. It is instructive to consider a single walker first. As a guiding wavefunction, we use the simplest one, an equal weight superposition of all configurations psi(x) =1.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"NSteps = 1000  # Number of Monte Carlo steps\nNStepsEquil = 100  # Number of Monte Carlo steps for equilibration\nNWalkers = 1  # Number of walkers\ndtau = 0.1    # imaginary time propagation step\n\nstartConfig = BosonConfig(Hilbert) # creates an initial configuration where all occupation numbers are 0\n\nproblem = GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ = EqualWeightSuperposition(), H, Hilbert)\nObserver = ConfigObserver(startConfig, NSteps, NWalkers) # Observer to measure the energy and configurations \nrunGFMC!(problem, NoObserver(), NStepsEquil) #run for NStepsEquil steps without observing to equilibrate\nrunGFMC!(problem, Observer, NSteps) #run for NSteps steps","category":"page"},{"location":"Example_transverseFieldIsing/#Evaluating-the-Results","page":"Example: Transverse Field Ising Model","title":"Evaluating the Results","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"Let's see the results. For open boundary conditions at the critical point h=J, we may compare to the exact solution. ","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"using CairoMakie, Statistics, Random\n\nfunction E_critPoint_exact(L, h=1, periodic=false)\n    (!periodic && h==1) || return NaN \n    \n    return 1 - csc(pi / (2 * (2 * L + 1)))\nend\n\nlet \n    MaxProjection = 20\n\n    energies = getEnergies(Observer, MaxProjection) \n    \n    tau = 0:MaxProjection-1 * dtau\n\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"Energy$$\")\n\n    lines!(ax, tau, energies, label=L\"Equal Weight Superposition$$\")\n\n    hlines!(ax, E_critPoint_exact(lattice_size,h,periodic), color=:black, label=L\"Exact$$\", linestyle=:dash)\n\n    axislegend(ax, position=:rt)\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"Run the code a few times and see what happens:","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"At tau=0 (for a single walker!), we will always obtain the variational energy of the guiding wavefunction.\nThe energy initially decreases with the number of projections.\nHowever, for larger tau, the energy is strongly affected by statistical fluctuations. It may either increase or go below the exact energy.\nWe may quantify this statistical error by looking at the standard deviation of the energy upon performing several runs (see below).\nProvided a large enough tau, such that the imaginary time projection is converged, the energy will be within the statistical error of the exact energy.","category":"page"},{"location":"Example_transverseFieldIsing/#Using-variational-wavefunctions","page":"Example: Transverse Field Ising Model","title":"Using variational wavefunctions","text":"","category":"section"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"The issue of errorbars growing exponentially with tau can be significantly alleviated by using more Walkers, i.e. setting NWalkers = 10 in the example above, or by using a more sophisticated guiding wavefunction. For example, it is easy to implement a short ranged Jastrow wavefunction which correlates nearest neighbors spins.","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"warning: Warning\nYou must always implement the logarithm of the wavefunction, i.e. log psi(x).","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"function ShortRangeJastrow(x)\n    res = 0.\n    for i in eachindex(x)[1:end-1]\n        res += 0.5x[i]*x[i+1]\n    end\n    return res\nend\nlogψ = logψJastrow\nlogψ = NaiveFunction(ShortRangeJastrow)\nNSteps = 4000\nNWalkers = 10\nP = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for i in 1:10])\nObservers = [ConfigObserver(startConfig, NSteps, NWalkers) for _ in 1:10]\n\nrunGFMC!(P, NoObserver(),200,logger=nothing) #equilibrate\nrunGFMC!(P, Observers,NSteps,logger=nothing)\n\n\nMaxProjection = 50\nenergies_jastrow = [getEnergies(Observer, MaxProjection) for Observer in Observers]\ntau = 0:MaxProjection-1 * dtau\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel=L\"$τ$ (imaginary time)\", ylabel=L\"Energy$$\")\n\n    lines!(ax, tau, mean(energies_jastrow), label=L\"Jastrow Wavefunction$$\")\n    band!(ax, tau, mean(energies_jastrow) - std(energies_jastrow), mean(energies_jastrow) + std(energies_jastrow), color=(:green, 0.2))\n\n    hlines!(ax, E_critPoint_exact(lattice_size), color=:black, label=L\"Exact$$\", linestyle=:dash)\n\n    axislegend(ax, position=:rt)\n    fig\nend","category":"page"},{"location":"Example_transverseFieldIsing/","page":"Example: Transverse Field Ising Model","title":"Example: Transverse Field Ising Model","text":"tip: Tip\nThere is already an efficient implementation of the Jastrow function. Simply use it as:vij_jastrow = zeros(Float32,lattice_size,lattice_size)\nfor i in axes(vij_jastrow, 1)[1:end-1]\n    vij_jastrow[i,i+1]=vij_jastrow[i+1,i] = 0.5\nend\n\nlogψJastrow = Jastrow(\n    zeros(Float32,lattice_size),\n    vij_jastrow,\n)It is advised to use variational Monte Carlo to optimize a variational wavefunction before using it in GFMC. A particularly useful package is Netket, which may be called from Julia via PyCall.","category":"page"},{"location":"#GreenFunctionMonteCarlo","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"","category":"section"},{"location":"","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"","category":"page"},{"location":"","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"using Markdown\nfunction remove_comments(input::String)::String\n    s1 = replace(input, r\"<!--.*?-->\" => \"\")\nend\nfunction strip_to_start(input::String)::String\n    start_index = findfirst(r\"<!-- START README \\(DO NOT DELETE THIS LINE!\\) -->\", input)\n    return start_index === nothing ? \"\" : input[last(start_index)+1:end]\nend\n\nMarkdown.parse(strip_to_start(read(\"../../README.md\", String)))","category":"page"}]
}
