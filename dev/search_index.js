var documenterSearchIndex = {"docs":
[{"location":"#GreenFunctionMonteCarlo","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"","category":"section"},{"location":"","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"","category":"page"},{"location":"#Internal-API","page":"GreenFunctionMonteCarlo","title":"Internal API","text":"","category":"section"},{"location":"","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo","text":"GreenFunctionMonteCarlo.AbstractObserver\nGreenFunctionMonteCarlo.AbstractPropagator\nGreenFunctionMonteCarlo.AbstractGFMCProblem\nGreenFunctionMonteCarlo.AbstractOperator\nGreenFunctionMonteCarlo.AbstractHilbertSpace\nGreenFunctionMonteCarlo.AbstractConstraint\nGreenFunctionMonteCarlo.AbstractSignFreeOperator\nGreenFunctionMonteCarlo.AbstractWalkerEnsemble\nGreenFunctionMonteCarlo.AbstractGuidingFunction\nGreenFunctionMonteCarlo.AbstractDiagObservable\nGreenFunctionMonteCarlo.AbstractMove\nGreenFunctionMonteCarlo.AbstractConfig\nGreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer\nGreenFunctionMonteCarlo.AbstractReconfigurationScheme\nGreenFunctionMonteCarlo.GreenFunctionMonteCarlo\nGreenFunctionMonteCarlo.isapplicable\nGreenFunctionMonteCarlo.get_offdiagonal_elements\nGreenFunctionMonteCarlo.InverseMove\nGreenFunctionMonteCarlo.get_move\nGreenFunctionMonteCarlo.allocate_GWF_buffers\nGreenFunctionMonteCarlo.propagateWalkers!\nGreenFunctionMonteCarlo.fulfills_constraint\nGreenFunctionMonteCarlo.DiagonalOperator\nGreenFunctionMonteCarlo.continuos_time_propagation!\nGreenFunctionMonteCarlo.pre_move_affect!\nGreenFunctionMonteCarlo.apply!\nGreenFunctionMonteCarlo.ConfigObserver\nGreenFunctionMonteCarlo.runGFMC!\nGreenFunctionMonteCarlo.minimizeReconfiguration!\nGreenFunctionMonteCarlo.GFMCProblem\nGreenFunctionMonteCarlo.reconfigurateWalkers!\nGreenFunctionMonteCarlo.Jastrow\nGreenFunctionMonteCarlo.NoObserver\nGreenFunctionMonteCarlo.EqualWeightSuperposition\nGreenFunctionMonteCarlo.NoLogger\nGreenFunctionMonteCarlo.SimpleLogger\nGreenFunctionMonteCarlo.ProgressBarLogger\nGreenFunctionMonteCarlo.NaiveFunction\nGreenFunctionMonteCarlo.CombinedObserver\nGreenFunctionMonteCarlo.ConfigurationObserver\nGreenFunctionMonteCarlo.BasicObserver\nGreenFunctionMonteCarlo.ProblemEnsemble","category":"page"},{"location":"#GreenFunctionMonteCarlo.AbstractObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractObserver","text":"Abstract supertype for observables in GFMC which are recorded during the run. Observables should always contain the table recording reconfiguration processes, the energies, and the total weights of each Markov step.\n\nInterface:\n\nsaveObservables_before!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers.\nsaveObservables_after!(Observables,i,Walkers,propagator): Saves the observables for the given iteration i and walker ensemble Walkers after reconfiguration.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractPropagator","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractPropagator","text":"AbstractPropagator\n\nAn abstract type representing a propagator. Examples include discrete or continuous time methods.\n\nInterface:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng()): Propagate the walkers in the ensemble using the specified moves and parameters.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractGFMCProblem","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractGFMCProblem","text":"Abstract type for GFMC problems.\n\nInterface:\n\nrunGFMC!(problem::AbstractGFMCProblem,args...;kwargs...): Run the GFMC algorithm for the given problem.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractOperator","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractOperator","text":"AbstractOperator\n\nAn abstract type representing a general operator. This serves as a base type for defining various specific operators in the context of the Green Function Monte Carlo project.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractHilbertSpace","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractHilbertSpace","text":"AbstractHilbertSpace\n\nAn abstract type representing a Hilbert space. This type serves as a base for defining various specific Hilbert spaces used in the project. Generally, a hilbert space should be defined by the number of sites, the number of local degrees of freedom (i.e. spin), and the constraint that the configurations must satisfy. \n\nInterface\n\nconstraint(HilbertSpace::AbstractHilbertSpace): Return the constraint that the configurations in the Hilbert space must satisfy.\nBase.size(HilbertSpace::AbstractHilbertSpace): Return the size of a config in the Hilbert space.\n\nInterface (optional)\n\nfulfills_constraint(x,HilbertSpace::AbstractHilbertSpace): Check if the given configuration x satisfies the constraint of the specified HilbertSpace. Defaults to constraint(HilbertSpace)(x).\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractConstraint","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractConstraint","text":"AbstractConstraint\n\nAn abstract type representing a constraint in the context of a Hilbert space.\n\nInterface\n\n(c)(x::AbstractArray): Check if the configuration x satisfies the constraint.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractSignFreeOperator","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractSignFreeOperator","text":"AbstractSignFreeOperator <: AbstractOperator\n\nAn abstract type representing a sign-free operator in the context of Green Function Monte Carlo simulations. \n\nInterface:\n\nget_diagonal(O::AbstractSignFreeOperator): return the diagonal operator associated with the sign-free operator O\ngetoffdiagonalelements(O::AbstractSignFreeOperator): return the weights associated with the off-diagonal operator O\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractWalkerEnsemble","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractWalkerEnsemble","text":"AbstractWalkerEnsemble\n\nAn abstract type that represents an ensemble of configurations (i.e. spins, bosons on a lattice for each walker) in the context of the Green Function Monte Carlo project. \n\nInterface (required)\n\ngetConfig(X::AbstractWalkerEnsemble,α):  get the configuration of the α-th walker in the ensemble.\ngetMoveWeights(X::AbstractWalkerEnsemble,α): get the weights of the moves for the α-th walker in the ensemble.\ngetBuffer(X::AbstractWalkerEnsemble,α): get the buffer associated with the α-th walker in the ensemble.\ngetWalkerWeights(X::AbstractWalkerEnsemble): get the weights of the Walkers in the ensemble.\n\nInterface (optional)\n\nBase.eachindex(X::AbstractWalkerEnsemble): iterate over the indices of the ensemble.\ngetNWalkers(X::AbstractWalkerEnsemble): get the number of walkers in the ensemble.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractGuidingFunction","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractGuidingFunction","text":"AbstractGuidingFunction\n\nAn abstract type for all guiding function implementations in Green Function Monte Carlo. Subtypes of this correspond to implementations of concrete guiding functions, particularly variational wavefunctions. For optimal performance, it is recommended to implement the function logpsidiff! for the specific guiding function type.\n\nInterface\n\nlogψ(x::AbstractArray): return the logarithm of the guiding function evaluated at the configuration x.\nlogψ(x::AbstractArray, H::AbstractHilbertSpace): return the logarithm of the guiding function evaluated at the configuration x in the specified HilbertSpace.\nlog_psi_diff(x::AbstractArray, dx::AbstractArray, logψ::AbstractGuidingFunction, Buffer::AbstractGuidingFunctionBuffer, Hilbert::AbstractHilbertSpace): return the logarithm of the ratio of the guiding function evaluated at the configuration x and x+dx in the specified HilbertSpace. Returns -Inf if the move is not applicable.\nget_params(logψ::AbstractGuidingFunction): return the parameters of the guiding function as a linear Array. It is recommended to use RecursiveArrayTools.jl for this purpose.\nHDF5.h5write(file::AbstractString, name::AbstractString, logψ::AbstractGuidingFunction): write the guiding function to an HDF5 file.\n\nInterface (optional)\n\nallocateGWFbuffers(logψ::AbstractGuidingFunction, NBuffers::Integer): allocate NBuffers instances of a buffer for the guiding function. Defaults to an array of EmptyGWFBuffer instances.\ncomputeGWFbuffer!(Buffer::AbstractGuidingFunctionBuffer, logψ::AbstractGuidingFunction, x): compute the full buffer for the guiding function at the configuration x. \npremoveaffect!(Buffer::AbstractGuidingFunctionBuffer, x, moves, logψ::AbstractGuidingFunction): perform any necessary operations before computing ratios ψx´_ψx.\npostmoveaffect!(Buffer::AbstractGuidingFunctionBuffer, x, dx, logψ::AbstractGuidingFunction): perform any necessary operations after the move is applied.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractDiagObservable","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractDiagObservable","text":"Abstract supertype for observables which are diagonal in the computational basis and may be measured for free in GFMC. An observable must be a function that takes a configuration and returns an array.\n\nInterface:\n\nobs(::O) returns the buffer array for the output of the observable.\nO(out,Conf): Writes the observable for the given configuration to the preallocated array out. Returns out.\nBase.copy(O::O): Returns a copy of the observable.\n\nIf no preallocated array is given, the observable defaults to using the buffer array obs(O).\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractMove","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractMove","text":"AbstractMove\n\nAbstract type representing a move, i.e. an operation that changes a configuration x to a new configuration x'.\n\nAbstract type representing a move operation in the context of Green Function Monte Carlo simulations.\n\nThis abstract type serves as a base for defining various move operations that can be performed during the simulation process. Specific move types should inherit from this abstract type and implement the required functionality.\n\nInterface\n\napply!(x::AbstractConfig, move::AbstractMove): Apply the move to the configuration x.\nisapplicable(x::AbstractConfig, move::AbstractMove, HilbertSpace::AbstractHilbertSpace): Check if the move is applicable to the configuration x within the specified HilbertSpace.\naffected_sites(move::AbstractMove): Return the sites affected by the move.\nmove_dx(move::AbstractMove,x::AbstractConfig): Return the values of the move applied to the configuration x. i.e. the change in x when the move is applied.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractConfig","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractConfig","text":"AbstractConfig{T,N}\n\nAn abstract type that represents a configuration (i.e. spins, bosons on a lattice).  This type is a subtype of AbstractArray{T,N}.\n\nParameters\n\nT: The type of the elements in the configuration.\nN: The number of dimensions of the configuration.\n\nInterface\n\nBase.parent(x::AbstractConfig): return the parent array\nBase.copy(x::AbstractConfig): create a full copy of the configuration\napply!(x::AbstractConfig, move::Any): apply a move to the configuration\nfulfills_constraints(x::AbstractConfig, HilbertSpace::AbstractHilbertSpace): check if the configuration satisfies the constraints of the Hilbert space\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractGuidingFunctionBuffer","text":"AbstractGuidingFunctionBuffer\n\nAn abstract type that serves as a base for defining guiding function buffer structures. \n\nInterface\n\nsetBuffer!(BA::AbstractGuidingFunctionBuffer, BB::AbstractGuidingFunctionBuffer): set the buffer BA to the values of the buffer BB.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.AbstractReconfigurationScheme","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.AbstractReconfigurationScheme","text":"AbstractReconfigurationScheme\n\nAn abstract type that serves as a base for defining different reconfiguration strategies  in the context of the Green Function Monte Carlo framework. \n\nInterface\n\nreconfigurateWalkers!(Walkers::AbstractWalkerEnsemble,reconfiguration::AbstractReconfigurationScheme,rng::Random.AbstractRNG)\nget_reconfigurationList(reconfiguration::AbstractReconfigurationScheme)\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.GreenFunctionMonteCarlo","text":"Green function Monte Carlo is a method to sample from the ground state of sign-problem free Hamiltonians, i.e. those which can be writte as math H_{xx'} ≤ 0 if math x != x'.\n\n\n\n\n\n","category":"module"},{"location":"#GreenFunctionMonteCarlo.isapplicable","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.isapplicable","text":"isapplicable(x::AbstractConfig, move::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if a given move is applicable to the current configuration within a specified Hilbert space.\n\nArguments\n\nx::AbstractConfig: The current configuration.\nmove::AbstractMove: The proposed move to be applied.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space in which the configuration and move are defined.\n\nReturns\n\nBool: true if the move is applicable, false otherwise.\n\nDefaults to applying the move to the configuration, checking if the constraints are satisfied, and then reverting the move.\n\nMake sure to implement this function for specific subtypes of AbstractConfig and AbstractHilbertSpace to ensure optimal performance. See also isapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint).\n\n\n\n\n\nisapplicable(x::AbstractConfig, move::AbstractMove, constraint::AbstractConstraint) -> Bool\n\nCheck if a given move is applicable to a configuration under a specified constraint.\n\nArguments\n\nx::AbstractConfig: The configuration to which the move will be applied.\nmove::AbstractMove: The move that is being checked for applicability.\nconstraint::AbstractConstraint: The constraint that must be satisfied for the move to be applicable.\n\nReturns\n\nBool: true if the move is applicable to the configuration under the given constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.get_offdiagonal_elements","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.get_offdiagonal_elements","text":"get_offdiagonal_elements(O::AbstractSignFreeOperator)\n\nReturn the weights associated with an AbstractSignFreeOperator object O. \n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.InverseMove","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.InverseMove","text":"struct InverseMove{T<:AbstractMove} <: AbstractMove\n\nA type representing an inverse move in a Monte Carlo simulation. This type is parameterized by T, which must be a subtype of AbstractMove. The InverseMove struct is used to encapsulate the concept of an inverse operation corresponding to a given move in the simulation.\n\nParameters\n\nT: A subtype of AbstractMove that specifies the type of move for which this struct represents the inverse.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.get_move","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.get_move","text":"get_move(O::AbstractOperator,idx::Integer)\n\nReturn the move associated with the operator O at index idx. \n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.allocate_GWF_buffers","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.allocate_GWF_buffers","text":"allocate_GWF_buffers(logψ::AbstractGuidingFunction, NBuffers::Integer, x)\n\nAllocates a specified number of guiding wave function (GWF) buffers.\n\nArguments\n\nlogψ::AbstractGuidingFunction: The guiding function for which the buffers are being allocated.\nNBuffers::Integer: The number of buffers to allocate.\nx: An exemplary configuration\n\nReturns\n\nAn array filled with NBuffers instances of AbstractGuidingFunctionBuffer. Defaults to an array of NotImplementedBuffer instances.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.propagateWalkers!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.propagateWalkers!","text":"Propagates walker ensemble X using a collection of moves according to the rules specified by the propagator P. \n\nUsage:\n\npropagateWalkers!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, propagator::AbstractPropagator, parallelization::AbstractParallelizationScheme, RNG::Random.AbstractRNG = Random.default_rng())\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.fulfills_constraint","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.fulfills_constraint","text":"fulfills_constraint(x::AbstractArray, HilbertSpace::AbstractHilbertSpace)\n\nCheck if the given configuration x satisfies the constraint of the specified HilbertSpace.\n\nArguments\n\nx::AbstractArray: The configuration to be checked.\nHilbertSpace::AbstractHilbertSpace: The Hilbert space whose constraint need to be satisfied.\n\nReturns\n\nBool: true if the configuration satisfies the constraint, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.DiagonalOperator","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.DiagonalOperator","text":"DiagonalOperator\n\nAn abstract type representing a diagonal operator in the context of Green Function Monte Carlo simulations. A diagonal operator is special in the sense that it will not change the configuration of the system when applied to it and will only return a number.\n\nInterface:\n\n(D::DiagonalOperator)(x) : return the value of the operator applied to the configuration x\n(D::DiagonalOperator)(x, params): return the value of the operator applied to the configuration x with parameters params, which can be used to store buffers.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.continuos_time_propagation!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.continuos_time_propagation!","text":"continuos_time_propagation!(WE::AbstractWalkerEnsemble, H::AbstractSignFreeOperator, logψ::AbstractGuidingFunction, Hilbert::AbstractHilbertSpace, dτ::Real, parallelization::MultiThreaded, RNG::Random.AbstractRNG = Random.default_rng())\n\nPerform continuous time propagation on a walker ensemble for a fixed time step dτ.\n\nArguments\n\nWE::AbstractWalkerEnsemble: The ensemble of walkers to be propagated.\nH::AbstractSignFreeOperator: The Hamiltonian operator used for propagation.\nlogψ::AbstractGuidingFunction: The guiding function for the propagation.\nHilbert::AbstractHilbertSpace: The Hilbert space in which the propagation occurs.\ndτ::Real: The time step for the propagation.\nw_avg_estimate::Real: An estimate of the average weight.\nparallelization::MultiThreaded: Parallelization settings for the propagation.\nRNG::Random.AbstractRNG: The random number generator to be used (default is Random.default_rng()).\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.pre_move_affect!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.pre_move_affect!","text":"Updates the guiding function buffer before any move is applied.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.apply!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.apply!","text":"apply!(x::AbstractConfig, move::AbstractMove)\n\nThrows a MethodError indicating that the apply! function has not been implemented for the given AbstractConfig type and move.\n\nArguments\n\nx::AbstractConfig: An instance of a type that is a subtype of AbstractConfig.\nmove::AbstractMove: A move or operation to be applied to the configuration x.\n\nThrows\n\nMethodError: Always thrown to indicate that the method needs to be implemented for specific subtypes of AbstractConfig.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.ConfigObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.ConfigObserver","text":"ConfigObserver(filename, config::AbstractConfig{T,N}, NSteps::Integer, NWalkers::Integer) where {T,N}\n\nCreates a combined observer that tracks energy, weight, reconfigurations and configurations of the walkers during the Monte Carlo simulation. The observer saves the data to a file with the given filename.\n\nArguments\n\nfilename::String: The name of the file where the configuration data will be saved.\nconfig::AbstractConfig{T,N}: The initial configuration object representing the system state.\nNSteps::Integer: The number of simulation steps to be observed.\nNWalkers::Integer: The number of walkers (or particles) in the simulation.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.runGFMC!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.runGFMC!","text":"runGFMC!(Walkers::AbstractWalkerEnsemble, Observables::AbstractObserver, reconfiguration::AbstractReconfigurationScheme, \n         range, propagator::AbstractPropagator, logψ::AbstractGuidingFunction, H::AbstractSignFreeOperator, \n         Hilbert::AbstractHilbertSpace, parallelizer::AbstractParallelizationScheme, logger::AbstractLogger, RNG::Random.AbstractRNG)\n\nRuns the Green Function Monte Carlo (GFMC) simulation for a given system.\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers representing the quantum state.\nObservables::AbstractObserver: The observer object used to measure physical quantities during the simulation.\nreconfiguration::AbstractReconfigurationScheme: The scheme used to reconfigure the walker ensemble to maintain population control.\nrange: The range of iterations or time steps for the simulation.\npropagator::AbstractPropagator: The propagator used to evolve the walkers.\nlogψ::AbstractGuidingFunction: The guiding function (logarithmic form) used for importance sampling.\nH::AbstractSignFreeOperator: The Hamiltonian operator of the system, assumed to be sign-free.\nHilbert::AbstractHilbertSpace: The Hilbert space on which the system is defined.\nparallelizer::AbstractParallelizationScheme: The parallelization scheme used to distribute computation across resources.\nlogger::AbstractLogger: The logger object used to record simulation progress.\nRNG::Random.AbstractRNG: The random number generator used for stochastic processes in the simulation.\n\nDescription\n\nThis function performs the GFMC simulation by evolving the walker ensemble using the provided propagator and guiding function. It measures observables diagonal in the computational Basis at each step and applies reconfiguration to control the walker population. The simulation is parallelized according to the specified parallelization scheme.\n\nNotes\n\nThe function modifies the Walkers object in place.\nEnsure that all input objects are properly initialized before calling this function.\n\n\n\n\n\nrunGFMC!(prob::GFMCProblem, Observables::AbstractObserver, range; logger = NoLogger(), rng = Random.default_rng())\n\nRun the Green's Function Monte Carlo (GFMC) simulation for the given problem.\n\nArguments\n\nprob::GFMCProblem: The GFMC problem instance containing the system configuration and parameters.\nObservables::AbstractObserver: An observer object to track and record observables during the simulation.\nrange: Integer or range: The range of iterations or steps over which the simulation will be performed.\nlogger: (Optional) A logger instance for logging simulation progress. Defaults to ProgressBarLogger(dt=0.1). Use NoLogger() or nothing to disable logging.\nrng: (Optional) A random number generator to ensure reproducibility. Defaults to Random.default_rng().\n\nReturns\n\nThis function modifies the prob and Observables in place to reflect the results of the simulation.\n\nNotes\n\nEnsure that the prob and Observables are properly initialized before calling this function.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.minimizeReconfiguration!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.minimizeReconfiguration!","text":"given a list of reconfiguration indices, minimizes the number of reconfigurations by swapping elements in the list. Each walker that survives a reconfiguration step remains unchanged while walkers that are killed get assigned to a new index.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.GFMCProblem","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.GFMCProblem","text":"struct GFMCProblem{WE<:AbstractWalkerEnsemble, Prop<:AbstractPropagator, GF<:AbstractGuidingFunction, \n                 SFO<:AbstractSignFreeOperator, HS<:AbstractHilbertSpace, PS<:AbstractParallelizationScheme, \n                 RS<:AbstractReconfigurationScheme} <: AbstractGFMCProblem\n\nRepresents a Green's Function Monte Carlo (GFMC) problem with the following type parameters:\n\nWE<:AbstractWalkerEnsemble: The type of the walker ensemble used in the simulation.\nProp<:AbstractPropagator: The propagator responsible for evolving the system.\nGF<:AbstractGuidingFunction: The guiding function used to improve the efficiency of the simulation.\nSFO<:AbstractSignFreeOperator: The operator ensuring sign-free sampling in the simulation, containing only negative elements on the off-diagonal.\nHS<:AbstractHilbertSpace: The Hilbert space in which the problem is defined.\nPS<:AbstractParallelizationScheme: The parallelization scheme used for distributing computation.\nRS<:AbstractReconfigurationScheme: The reconfiguration scheme used to manage walker populations.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.reconfigurateWalkers!","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.reconfigurateWalkers!","text":"Performs an efficient reconfiguration of walkers. This reconfiguration will not remove walkers if they all have the same weight, which increases the efficiency as more walkers can contribute to the average.\n\nMatteo Calandra Buonaura and Sandro Sorella Phys. Rev. B 57, 11446 (1998)\n\nArguments\n\nWalkers::AbstractWalkerEnsemble: The ensemble of walkers to be reconfigured.\nreconfigurationList: A list of indices that will be reconfigured.\nrng::Random.AbstractRNG: The random number generator to be used.\n\n\n\n\n\n","category":"function"},{"location":"#GreenFunctionMonteCarlo.Jastrow","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.Jastrow","text":"struct Jastrow{T<:Real} <: AbstractGuidingFunction\n\nA structure representing the Jastrow factor in a variational Monte Carlo simulation. This function strikes a good balance between accuracy and computational efficiency in the context of Green Function Monte Carlo. log(ψ(x)) = sum_i m_i x_i + frac12sum_ij v_ij x_i x_j\n\nType Parameters\n\nT<:Real: The numeric type used for the parameters of the Jastrow factor  (e.g., Float64, Float32).\n\nUsage\n\nlogψ = Jastrow(N,Float64) # Create a Jastrow factor for N sites with parameters of type Float64. logψ = Jastrow(conf,Float64) # Create a Jastrow factor for configurations similar to conf.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.NoObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.NoObserver","text":"NoObserver <: AbstractObserver\n\nAn observer type that does not save anything. Can be used to evolve the system in the most efficient way, i.e. for equilibration.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.EqualWeightSuperposition","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.EqualWeightSuperposition","text":"struct EqualWeightSuperposition <: AbstractGuidingFunction\n\nRepresents a guiding function that models an equal weight superposition of states, i.e. ψ(x) = 1 for all x, provided that the configuration x is a valid configuration satisfying all constraints. This structure is a subtype of AbstractGuidingFunction and is used in the context of variational calculations within the Green Function Monte Carlo framework.\n\nSee Also\n\nAbstractGuidingFunction: The abstract type that this struct extends.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.NoLogger","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.NoLogger","text":"NoLogger <: AbstractLogger\n\nA placeholder implementation that does not perform any logging.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.SimpleLogger","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.SimpleLogger","text":"struct SimpleLogger <: AbstractLogger\n\nA simple logger implementation that inherits from AbstractLogger.\n\nFields\n\nn_report::Int: The number of steps in the log report.\n\nThis logger can be used to control and manage logging behavior in a straightforward manner.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.ProgressBarLogger","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.ProgressBarLogger","text":"ProgressBarLogger(; kwargs...)\n\nCreates a progress bar logger with customizable update intervals and additional options.\n\nArguments\n\nkwargs...: Additional keyword arguments to customize the behavior of the progress bar logger. See GreenFunctionMonteCarlo.ProgressMeter.Progress for more details.\n\nReturns\n\nA progress bar logger instance that can be used to track and display progress in a task.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.NaiveFunction","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.NaiveFunction","text":"provides a naive wrapper for a guiding function which does not use any buffer. Useful for debugging and testing\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.CombinedObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.CombinedObserver","text":"CombinedObserver{T}\n\nA struct that represents a combined observer, which is a collection of multiple observers grouped together.  This allows for observing multiple quantities or behaviors simultaneously.\n\nFields\n\nObservers::T: A collection containing the individual observers.\n\nUsage\n\nThis struct is useful for combining multiple observer objects into a single entity, enabling them to be managed and used collectively.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.ConfigurationObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.ConfigurationObserver","text":"struct ConfigurationObserver{T} <: AbstractObserver\n\nSaves the configurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the configurations.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.BasicObserver","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.BasicObserver","text":"struct BasicObserver{DT<:AbstractFloat} <: AbstractObserver\n\nSaves the energies, weights and reconfigurations of the walkers during the Monte Carlo simulation.\n\nType Parameters\n\nT: Data type for the energies and weights.\n\n\n\n\n\n","category":"type"},{"location":"#GreenFunctionMonteCarlo.ProblemEnsemble","page":"GreenFunctionMonteCarlo","title":"GreenFunctionMonteCarlo.ProblemEnsemble","text":"ProblemEnsemble{P<:AbstractGFMCProblem} <: AbstractGFMCProblem\n\nRun multiple GFMC problems in parallel. Useful to estimate errors.\n\nUsage example:\n\nP = ProblemEnsemble([GFMCProblem1, GFMCProblem2, ...])\n\nproblems = ProblemEnsemble([GFMCProblem(startConfig, NWalkers, ContinuousTimePropagator(dtau); logψ, H, Hilbert) for _ in 1:10])\n\nObservers = [ConfigObserver(\"output_$i.h5\",startConfig, NSteps, NWalkers) for i in 1:10] #note that each observer must have its own file\n\nrunGFMC!(problems, NoObserver(),100) #equilibrate\nrunGFMC!(problems, Observers)\n\n\n\n\n\n","category":"type"}]
}
